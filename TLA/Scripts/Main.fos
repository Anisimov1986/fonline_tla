// FOS Server
// Author: cvet

#include "Tla"
#include "AiSettings"
#include "TeamsTable"

#pragma property Critter PrivateServer dict< uint, uint > StealExpCount
#pragma property Critter PrivateServer dict< uint, uint > FirstAidCount

// Imports
import void InitializeGame() from "Config";
import bool OnUseExplode( Critter& cr, Item& explode, Critter@ targetCr, Item@ targetItem, const Item@ targetScen, uint timer ) from "Explode";
import bool UseItemOnCar( Critter& cr, Item& car, Item& item ) from "Car";
import bool UseSkillOnCar( Critter& cr, Item& car, CritterProperty skill ) from "Car";
import void WorldmapInit() from "Worldmap";
import void SetStartLocation( Critter& cr ) from "Replication";
import void SetReplicationTime( Critter& cr ) from "Replication";
import void ReplicateCritter( Critter& cr ) from "Replication";
import void CombatAttack( Critter& cr, Critter& target, Item& weapon, uint8 weaponMode, const Item@ ammo ) from "Combat";
import bool TryRepairItem( Critter& cr, Item& item ) from "Repair";
import bool WantedSignSet( Item& wantedSign, string& name, uint cost ) from "Wanted";
import bool IsReadableBook( hash pid ) from "Books";
import void TryReadBook( Critter& cr, Item& book ) from "Books";
import void UseDrug( Critter& cr, Item& drug ) from "Drugs";
import void UseDrugOn( Critter& cr, Critter& onCr, Item& drug ) from "Drugs";
import bool UseGeiger( Critter& cr, Item& geiger ) from "Geiger";
import bool UseItemOnGeiger( Critter& cr, Item& geiger, Item& item ) from "Geiger";
import bool UseSkillOnGeiger( Critter& cr, Item& geiger, CritterProperty skill ) from "Geiger";
import void CallTownSupply( Critter& victim, Critter& hostile ) from "TownSupply";
import bool UseSkillOnLocker( Critter& cr, Item& locker, CritterProperty skill ) from "Lockers";
import bool PerkCheck( Critter& cr, CritterProperty perk ) from "Perks";
import void CritterGenerate( dict< CritterProperty, int >& props ) from "Parameters";
import void CaravansInit() from "Caravan";
import int  GetDeteriorationProcent( Item& item ) from "Repair";
import void SetDeterioration( Item& item, int deteriorationProcent ) from "Repair";
import void NpcProcessLevel( Critter& npc ) from "Parameters";
import bool IsPermanentDeath( uint id ) from "Replication";
import bool SetPlayerStoryLineLocation( Critter& player )  from "MainIntro";
import void EditRadioSettings( Critter& player, Item& radio ) from "Radio";
import void SetNoPvp() from "NoPvpMaps";
import void OnCritterMapOut( Critter& cr, Map& map ) from "NoPvpMaps";
import void OnCitterMapIn( Critter& cr, Map& map ) from "NoPvpMaps";
import void DeclareEvents() from "GameEvent";
import void CheckAllGameEvents() from "GameEvent";
import void PlaceLoot2Container( Map& map, Critter& cr ) from "GameEventCaches";
import void StartMessenger() from "BulletinBoard";
import void SaveMessengerData() from "BulletinBoard";
import void CountEmpRocketTests( Critter& player, Critter& target ) from "Navarro";
import void OnCritterKilled( Critter& cr, Critter@ killer ) from "Hunter";
import bool BarterAllowed( int crId, Item@[]& buyItems,  Item@[]& saleItems ) from "LimitedBarter";
import uint CheckPlayerName( const string& name ) from "Parameters";
import bool Item_Weapon_IsHtHAttack( const Item& item, uint8 mode ) from "Parameters";
import void ReadHolodisk( Critter& cr, Item& holo ) from "Holodisk";
import void AddHolodiskInfo( Critter& cr, uint holoNum ) from "Holodisk";

void ModuleInit()
{
    __EventInit.Subscribe( init );
    __EventStart.Subscribe( start );
    __EventGenerateWorld.Subscribe( generate_world );
    __EventCritterAttack.Subscribe( critter_attack );
    __EventCritterAttacked.Subscribe( critter_attacked );
    __EventCritterStealing.Subscribe( critter_stealing );
    __EventCritterUseItem.Subscribe( critter_use_item );
    __EventCritterUseSkill.Subscribe( critter_use_skill );
    __EventCritterReloadWeapon.Subscribe( critter_reload_weapon );
    __EventCritterInit.Subscribe( critter_init );
    __EventCritterFinish.Subscribe( critter_finish );
    __EventCritterIdle.Subscribe( critter_idle );
    __EventCritterDead.Subscribe( critter_dead );
    __EventCritterRespawn.Subscribe( critter_respawn );
    __EventMapCritterIn.Subscribe( map_critter_in );
    __EventMapCritterOutEx.Subscribe( map_critter_out );
    __EventMapCheckLook.Subscribe( check_look );
    __EventMapCheckTrapLook.Subscribe( check_trap_look );
    __EventItemsBarter.Subscribe( items_barter );
    __EventWorldSave.Subscribe( world_save );
    __EventPlayerRegistration.Subscribe( player_registration );
    __EventPlayerLogin.Subscribe( player_login );
    __EventPlayerGetAccess.Subscribe( player_getaccess );
    __EventPlayerAllowCommand.Subscribe( player_allowcommand );
	// Не будет работать, у оригинального map_loop нет 
	__EventMapLoopEx.Subscribe( map_loop );
}

// Called on map loop
void map_loop( Map& map, uint loopIndex )
{
	switch (loopIndex)
	{
		case 1:
			__EventMapLoop1.Raise(map);
			break;
		case 2:
			__EventMapLoop2.Raise(map);
			break;
		case 3:
			__EventMapLoop3.Raise(map);
			break;
		case 4:
			__EventMapLoop4.Raise(map);
			break;
		case 5:
			break;	
	}

	}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called before world generation.
void init()
{
    InitializeGame();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
    // Global map initialization
    WorldmapInit();

    // Caravans initialization
    CaravansInit();

    // NoPvP initialization
    SetNoPvp();

    // Game Events initialization
    DeclareEvents();
    CheckAllGameEvents();

    // Bulletin boards
    StartMessenger();
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      50000
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world generation.
bool generate_world( uint16& multiplier, uint16& year, uint16& month, uint16& day, uint16& hour, uint16& minute )
{

    multiplier = 20;
    year = 2246;
    month = 10;
    day = 30;
    hour = 1;
    minute = 0;

    Log( "Generate world..." );
    if( CreateLocation( Content::Location::den, 475, 275, null ) == 0 ||
        CreateLocation( Content::Location::klamath, 375, 125, null ) == 0 ||
        CreateLocation( Content::Location::modoc, 925, 275, null ) == 0 ||
        CreateLocation( Content::Location::vault_city, 1225, 325, null ) == 0 ||
        CreateLocation( Content::Location::gecko, 1275, 225, null ) == 0 ||
        CreateLocation( Content::Location::broken_hills, 1175, 875, null ) == 0 ||
        CreateLocation( Content::Location::new_reno, 925, 925, null ) == 0 ||
        CreateLocation( Content::Location::sierra_army_depot, 914, 814, null ) == 0 ||
        CreateLocation( Content::Location::vault_15, 1275, 1425, null ) == 0 ||
        CreateLocation( Content::Location::ncr, 1125, 1425, null ) == 0 ||
        CreateLocation( Content::Location::cathedral, 932, 64, null ) == 0 ||
        CreateLocation( Content::Location::mariposa, 675, 1425, null ) == 0 ||
        CreateLocation( Content::Location::redding, 675, 525, null ) == 0 ||
        CreateLocation( Content::Location::san_francisco, 475, 1325, null ) == 0 ||
        CreateLocation( Content::Location::navarro, 168, 866, null ) == 0 ||
        CreateLocation( Content::Location::arroyo, 175, 125, null ) == 0 ||
        CreateLocation( Content::Location::primal_tribe, 120, 578, null ) == 0 ||
        CreateLocation( Content::Location::vault_13, 975, 1425, null ) == 0 ||
        CreateLocation( Content::Location::barter_ground, 690, 760, null ) == 0 ||
        CreateLocation( Content::Location::atoll, 310, 1365, null ) == 0 ||
        CreateLocation( Content::Location::raiders, 1166, 666, null ) == 0 ||
        CreateLocation( Content::Location::replication_1, 383, 230, null ) == 0 ||
        CreateLocation( Content::Location::replication_2, 964, 363, null ) == 0 ||
        CreateLocation( Content::Location::replication_3, 614, 637, null ) == 0 ||
        CreateLocation( Content::Location::replication_4, 1065, 832, null ) == 0 ||
        CreateLocation( Content::Location::replication_hell, 777, 466, null ) == 0 )
    {
        Log( "Generate world fail!" );
        return false;
    }
    Log( "Generate world complete." );
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attack( Critter& cr, Critter& target, Item& weapon, uint8 weaponMode, const Item@ ammo )
{
    if( cr.IsPlayer() && valid( ammo ) && ammo.ProtoId == Content::Item::emp_rocket && target.BodyType == BT_ROBOT )
        CountEmpRocketTests( cr, target );
    cr.TimeoutAggressor = __FullSecond + REAL_MINUTE( 1 );
    CombatAttack( cr, target, weapon, weaponMode, ammo );
	
	//R17
	Critter@[] npcs;
    if( cr.GetCritters( false, FIND_LIFE_AND_KO | FIND_ONLY_NPC, npcs ) > 0 )
    {
		for( uint i = 0; i < npcs.length(); i++ )
        {
            Critter@ npc = npcs[ i ];
			if(valid(npc))
				__EventCritterSomeCritterAttack.Raise(npc, cr, target, weapon, weaponMode, ammo);
        }
	}	
	__EventCritterAttacked.Raise(target, cr);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attacked( Critter& cr, Critter& attacker )
{
	//R17
	Critter@[] npcs;
    if( cr.GetCritters( false, FIND_LIFE_AND_KO | FIND_ONLY_NPC, npcs ) > 0 )
    {
		for( uint i = 0; i < npcs.length(); i++ )
        {
            Critter@ npc = npcs[ i ];
			if(valid(npc))
				__EventCritterSomeCritterAttacked.Raise(npc, cr, attacker);
        }
	}

    if( cr.IsPlayer() )
        return;                             // Diable player helping
    else
        AddAttackPlane( cr, 0, attacker );  // Answer on attack

    uint helpers = 0;
    uint maxHelpers = 10 - attacker.Charisma;
    maxHelpers = CLAMP( maxHelpers, 2, 8 );

    Critter@[] critters;
    cr.GetCritters( true, FIND_LIFE_AND_KO | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        NpcPlane@ plane = critters[ i ].GetCurPlane();
        if( valid( plane ) && plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == attacker.Id )
        {
            helpers++;
            if( helpers >= maxHelpers )
                return;                    // No help needed
            @critters[ i ] = null;         // Exclude this critter
        }
    }

    int  crHpProc = cr.CurrentHp * 100 / cr.MaxLife;
    uint teamId = cr.TeamId;
    uint attackerTeamId = attacker.TeamId;
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@ someCr = critters[ i ];
        if( not valid( someCr ) )
            continue;                           // Skip excluded

        uint someCrTeamId = someCr.TeamId;
        if( attackerTeamId == someCrTeamId )
            continue;                                         // No attack temmate

        int teamParity = TEAM_PARITY( someCrTeamId, teamId ); // From -> To
        switch( teamParity )
        {
        case Ignore:
            continue;
        case Anyway:
            break;
        case NotBusy:
            if( someCr.IsCurPlane( AI_PLANE_ATTACK ) )
                continue;
            break;
        case HpLess10:
            if( crHpProc >= 10 )
                continue;
            break;
        case HpLess30:
            if( crHpProc >= 30 )
                continue;
            break;
        case HpLess50:
            if( crHpProc >= 50 )
                continue;
            break;
        case IfDead:
            if( not cr.IsDead() )
                continue;
            break;
        case GoodPerson:
            if( attacker.IsNpc() || cr.Charisma < 5 || cr.Karma < 0 )
                continue;
            break;
        default:
            continue;
        }

        AddAttackPlane( someCr, 0, attacker );
        helpers++;
        if( helpers >= maxHelpers )
            break;                             // Enough
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter steal another.
bool critter_stealing( Critter& cr, Critter& thief, Item& item, uint count )
{
    thief.TimeoutAggressor = __FullSecond + REAL_MINUTE( 1 );

    if( cr.IsDead() || IS_TIMEOUT( cr.TimeoutBattle ) || IS_TIMEOUT( thief.TimeoutBattle ) )
    {
        thief.LastStealCrId = 0;
        thief.StealCount = 0;
        return false;
    }

    if( cr.IsNoPvp || thief.IsNoPvp )
    {
        thief.Say( SAY_NETMSG, "No PvP." );
        return false;
    }

    int dir1 = cr.Dir;
    int dir2 = thief.Dir;
    int kDir = MAX( dir1, dir2 ) - MIN( dir1, dir2 );
    if( kDir > 3 )
        kDir = 6 - kDir;

    int steal = thief.SkillSteal;
    if( steal <= 0 )
        steal = 1;
    int size = item.Volume;
    if( size <= 0 )
        size = 1;

    // Perk pickpocket, ignore size and facing
    if( thief.PerkPickpocket != 0 )
    {
        kDir = 0;
        size = 1;
    }

    // Count modifier
    int kCount = count / steal;
    if( kCount <= 0 )
        kCount = 1;

    // Check time of stealing
    uint lastStealCrId = thief.LastStealCrId;
    uint stealCount = thief.StealCount;
    if( lastStealCrId == cr.Id && IS_TIMEOUT( thief.TimeoutStealing ) )
        steal -= steal * stealCount * 9 / 100;

    // Calc
    int  k = ( steal - kDir * 10 ) / ( size * kCount );
    k = CLAMP( k, 5, 95 );
    bool success = !( Random( 1, 100 ) > k );

    if( success )
    {
        // Add experience     10,30,60,100,150,210,280,360,450,550,660,780
        const int[] stealExp = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120 };

        if( lastStealCrId == cr.Id && IS_TIMEOUT( thief.TimeoutStealing ) )
        {
            stealCount++;
            if( stealCount > 11 )
                stealCount = 11;
            thief.StealCount = stealCount;
        }
        else
        {
            thief.LastStealCrId = cr.Id;
            thief.StealCount = 0;
        }

        thief.TimeoutStealing = STEAL_TIMEOUT( thief );
        if( cr.IsNpc() )
        {
            auto stealExpCount = cr.StealExpCount;
            stealExpCount.setIfNotExist( thief.Id, 0 );
            if( stealExpCount[ thief.Id ] < 12 )
            {
                thief.Experience += stealExp[ stealCount ];
                AddScore( thief, SCORE_THIEF, 1 );
            }
            stealExpCount[ thief.Id ] = stealExpCount[ thief.Id ] + 1;
            cr.StealExpCount = stealExpCount;
        }
    }
    else
    {
        thief.LastStealCrId = 0;
        thief.StealCount = 0;

        if( cr.IsNpc() )
        {
            int thiefHp = thief.CurrentHp;
            AddAttackPlane( cr, 0, thief, thiefHp< 10 || Random( 1, 10 ) > cr.Luck + 4 || cr.Charisma < 3 ? __DeadHitPoints : Random( thiefHp / 4, thiefHp / 2 ) );
        }
    }

	//R17 Доп. события
	Critter@[] npcs;
    if( thief.GetCritters( false, FIND_LIFE_AND_KO | FIND_ONLY_NPC, npcs ) > 0 )
    {
		for( uint i = 0; i < npcs.length(); i++ )
        {
            Critter@ npc = npcs[ i ];
			if(valid(npc))
			{
				__EventCritterSomeCritterUseSkill.Raise(npc, thief, CritterProperty::SkillSteal,
				cr, null, null);
				__EventCritterSomeCritterStealing.Raise( npc, thief, cr, item, count );
			}	
				//# pragma event "EventCritterSomeCritterUseSkill( Critter& critter, 
				// Critter& whoUse, CritterProperty skill, Critter@ onCritter, Item@ onItem, const Item@ onScenery )" deferred
        }
	}
	
	
    return success;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, const Item@ targetScen, uint param )
{
    bool isPlayer = cr.IsPlayer();
    hash pid = item.ProtoId;
    bool useOnSelf = ( not valid( targetCr ) && not valid( targetItem ) && not valid( targetScen ) );

    // Holodisk
    if( useOnSelf && item.IsHolodisk )
    {
        ReadHolodisk( cr, item );
        return true;
    }

    // Radio
    if( item.IsRadio && useOnSelf )
    {
        if( isPlayer )
            EditRadioSettings( cr, item );
        return true;
    }

    // Book reading
    if( useOnSelf && IsReadableBook( pid ) )
    {
        TryReadBook( cr, item );
        return true;
    }

    // Explosion
    if( OnUseExplode( cr, item, targetCr, targetItem, targetScen, param ) )
        return true;

    // Cars
    if( valid( targetItem ) && targetItem.Type == ItemType::Car && UseItemOnCar( cr, targetItem, item ) )
        return true;

    // Drugs
    if( item.Type == ItemType::Drug )
    {
        if( useOnSelf )
            UseDrug( cr, item );
        else if( valid( targetCr ) )
            UseDrugOn( cr, targetCr, item );
        else
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
        return true;
    }

    // Play dice
    if( pid == Content::Item::dice )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_DICE_THROW, "$result" + Random( 1, 6 ) );
        return true;
    }
    if( pid == Content::Item::loaded_dice )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_DICE_THROW, "$result" + uint( ( item.Id % 6 ) + 1 ) );
        return true;
    }

    // Magic ball
    if( pid == Content::Item::magic_8_ball )
    {
        // cr.SayMsg(SAY_EMOTE_ON_HEAD,TEXTMSG_TEXT,Random(1,2)==1?STR_MAGIC_BALL_YES:STR_MAGIC_BALL_NO);
        return true;
    }

    // Cosmetic
    if( pid == Content::Item::cosmetic_case && cr.Gender == GENDER_FEMALE )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_COSMETIC_USE );
        return true;
    }

    // Cigarettes smoking
    if( pid == Content::Item::cigarettes && _CritCountItem( cr, Content::Item::lighter ) > 0 )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_CIGARETTES_SMOKE );
        return true;
    }

    // Geiger counter
    if( pid == Content::Item::geiger_counter && useOnSelf && UseGeiger( cr, item ) )
        return true;
    if( valid( targetItem ) && targetItem.ProtoId == Content::Item::geiger_counter && UseItemOnGeiger( cr, targetItem, item ) )
        return true;

	//R17 Доп. события
	Critter@[] npcs;
    if( cr.GetCritters( false, FIND_LIFE_AND_KO | FIND_ONLY_NPC, npcs ) > 0 )
    {
		for( uint i = 0; i < npcs.length(); i++ )
        {
            Critter@ npc = npcs[ i ];
			if(valid(npc))
				__EventCritterSomeCritterUseItem.Raise(npc, cr, item, targetCr, targetItem, targetScen, param);
        }
	}	
		
		
    // Take process to engine
    return false;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use skill.
bool critter_use_skill( Critter& cr, CritterProperty skill, Critter@ targetCr, Item@ targetItem, const Item@ targetScen )
{
    bool isPlayer = cr.IsPlayer();

    // Cars
    if( valid( targetItem ) && targetItem.Type == ItemType::Car && UseSkillOnCar( cr, targetItem, skill ) )
        return true;

    // Geiger counter
    if( valid( targetItem ) && targetItem.ProtoId == Content::Item::geiger_counter && UseSkillOnGeiger( cr, targetItem, skill ) )
        return true;

    // Doors or containers
    if( valid( targetItem ) && ( targetItem.Type == ItemType::Door || targetItem.Type == ItemType::Container ) && UseSkillOnLocker( cr, targetItem, skill ) )
        return true;

    switch( skill )
    {
    case SKILL_PICK_ON_GROUND:     // Pick item or scenery on ground
    {
        // Scenery
        if( valid( targetScen ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
            return true;
        }

        // Wanted
        if( valid( targetItem ) && targetItem.ProtoId == Content::Item::wanted_sign && WantedSignSet( targetItem, cr.Name, Random( 1000, 2000 ) ) )
            return true;
        // Explosion
        if( valid( targetItem ) && targetItem.ProtoId == Content::Item::active_mine && OnUseExplode( cr, targetItem, null, null, null, 0 ) )
            return true;

        // Pick some item
        if( valid( targetItem ) )
        {
            Item@ item = targetItem;
            if( not item.IsCanPickUp )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
                break;
            }

            int freeWeight = cr.CarryWeight - cr.ItemsWeight();
            if( freeWeight >= int(item.Weight * item.Count) )
            {
                // Pick full
                MoveItem( item, 0, cr );
            }
            else
            {
                // Pick half
                if( item.Stackable && freeWeight >= int(item.Weight) )
                    MoveItem( item, freeWeight / item.Weight, cr );
                // Overweight
                else
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_OVERWEIGHT );
            }
        }
    }
    break;
    case SKILL_PUT_CONT:      // Put item in container, only targetItem is valid
    case SKILL_TAKE_CONT:     // Take item from container, only targetItem is valid
    case SKILL_TAKE_ALL_CONT: // Take all items from critter or item container
        return false;         // Allow transactions
    case SKILL_LOOT_CRITTER:  // Loot critter, only targetCr is valid
        cr.Action( ACTION_PICK_CRITTER, 0, null );
        cr.ShowContainer( targetCr, null, TRANSFER_CRIT_LOOT );
        return true;
    case SKILL_PUSH_CRITTER:     // Push critter, only targetCr is valid
        cr.Action( ACTION_PICK_CRITTER, 2, null );
        if( ( !IS_TIMEOUT( cr.TimeoutBattle ) && !IS_TIMEOUT( targetCr.TimeoutBattle ) ) &&
            ( targetCr.IsPlayer() || ( targetCr.IsNoPlanes() && targetCr.GetTalkedPlayers( null ) == 0 ) ) )
            targetCr.MoveRandom();
        return true;
    case CritterProperty::SkillScience:
    {
        // Radio
        if( valid( targetItem ) && targetItem.IsRadio && targetItem.Accessory == ItemOwnership::CritterInventory && targetItem.CritId == cr.Id )
        {
            if( isPlayer )
                EditRadioSettings( cr, targetItem );
            return true;
        }

        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );             // Todo: "You fail to learn anything."
    }
    break;
    case CritterProperty::SkillRepair:
    {
        // Generic repair
        if( valid( targetItem ) && targetItem.Accessory == ItemOwnership::CritterInventory && targetItem.Deteriorable && TryRepairItem( cr, targetItem ) )
            return true;

        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
    }
    break;
    case CritterProperty::SkillSneak:
    {
        if( cr.IsHide )
            cr.IsHide = false;
        else if( not isPlayer )
            cr.IsHide = true;
        else
        {
            if( IS_TIMEOUT( cr.TimeoutSneak ) )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_TIMEOUT_SNEAK_WAIT );
            else
                cr.IsHide = true;
        }
    }
    break;
    case CritterProperty::SkillSteal:
    {
        if( valid( targetItem ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
        }
        else if( valid( targetCr ) )
        {
            // Loot
            if( targetCr.IsDead() )
            {
                cr.Action( ACTION_PICK_CRITTER, 0, null );
                cr.ShowContainer( targetCr, null, TRANSFER_CRIT_LOOT );
            }
            // Steal
            else
            {
                if( isPlayer && IS_TIMEOUT( cr.TimeoutSkSteal ) )
                {
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );
                }
                else
                {
                    cr.Action( ACTION_PICK_CRITTER, 1, null );
                    cr.ShowContainer( targetCr, null, TRANSFER_CRIT_STEAL );
                    cr.TimeoutSkSteal = STEAL_TIMEOUT( cr );
                    cr.LastStealCrId = 0;
                    cr.StealCount = 0;
                }
            }
        }
        else
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
        }
    }
    break;
    case CritterProperty::SkillFirstAid:
    {
        if( valid( targetItem ) || valid( targetScen ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
            break;
        }

        if( not valid( targetCr ) )
            @targetCr = cr;
        bool is_self = ( targetCr.Id == cr.Id );

        if( targetCr.IsDead() )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NORESSURECT );
            break;
        }

        if( targetCr.CurrentHp >= targetCr.MaxLife )
        {
            if( _CritIsInjured( targetCr ) )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NOFIRSTAID_NEEDDOCTOR );
            else if( is_self )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NONEED_FIRSTAID );
            break;
        }

        if( isPlayer && IS_TIMEOUT( cr.TimeoutSkFirstAid ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );
            break;
        }

        int  sk = cr.SkillFirstAid;
        hash activePid = cr.GetSlotItem( SLOT_HAND1 ).ProtoId;
        if( activePid == Content::Item::first_aid_kit )
        {
            sk += 25;
            if( Random( 0, 30 ) == 0 )
                cr.DeleteItem( Content::Item::first_aid_kit, 1 );
        }
        else if( activePid == Content::Item::field_medic_kit )
        {
            sk += 50;
            if( Random( 0, 30 ) == 0 )
                cr.DeleteItem( Content::Item::field_medic_kit, 1 );
        }
        int mod = 11 - cr.Luck;
        mod = CLAMP( mod, 1, 10 );
        int heal = Random( sk / mod, sk );
        if( heal < 1 )
            heal = 1;
        if( cr.PerkVampireRegeneration != 0 )
            heal += 5;
        int curHp = targetCr.CurrentHp;
        int maxHp = targetCr.MaxLife;
        if( curHp + heal > maxHp )
            heal = maxHp - curHp;
        targetCr.CurrentHp += heal;

        cr.Say( SAY_NETMSG, "+" + heal );
        if( not is_self )
            targetCr.Say( SAY_NETMSG, "+" + heal );

        if( isPlayer )
        {
            auto firstAidCount = cr.FirstAidCount;
            firstAidCount.setIfNotExist( targetCr.Id, 0 );
            if( firstAidCount[ targetCr.Id ] < 10 )
                cr.Experience += heal * 3;
            firstAidCount[ targetCr.Id ] = firstAidCount[ targetCr.Id ] + 1;
            cr.FirstAidCount = firstAidCount;

            cr.TimeoutSkFirstAid = FIRST_AID_TIMEOUT( cr );
            AddScore( cr, SCORE_DOCTOR, 1 );
        }
    }
    break;
    case CritterProperty::SkillDoctor:
    {
        if( valid( targetItem ) || valid( targetScen ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
            break;
        }

        if( not valid( targetCr ) )
            @targetCr = cr;
        bool is_self = ( targetCr.Id == cr.Id );

        if( targetCr.IsDead() )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NORESSURECT );
            break;
        }

        if( not _CritIsInjured( targetCr ) )
        {
            if( targetCr.CurrentHp < targetCr.MaxLife )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NODOCTOR_NEEDFIRSTAID );
            else if( is_self )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NONEED_DOCTOR );
            break;
        }

        if( isPlayer && IS_TIMEOUT( cr.TimeoutSkDoctor ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );
            break;
        }

        int  uninjured = 0;
        int  sk = cr.SkillDoctor;
        hash activePid = cr.GetSlotItem( SLOT_HAND1 ).ProtoId;
        if( activePid == Content::Item::doctors_bag )
        {
            sk += 25;
            if( Random( 0, 30 ) == 0 )
                cr.DeleteItem( Content::Item::doctors_bag, 1 );
        }
        else if( activePid == Content::Item::paramedics_bag )
        {
            sk += 50;
            if( Random( 0, 30 ) == 0 )
                cr.DeleteItem( Content::Item::paramedics_bag, 1 );
        }

        CritterProperty[] damages = { CritterProperty::IsDamagedEye, CritterProperty::IsDamagedRightArm, CritterProperty::IsDamagedLeftArm, CritterProperty::IsDamagedRightLeg, CritterProperty::IsDamagedLeftLeg };
        for( uint i = 0; i < damages.length(); i++ )
        {
            if( targetCr.GetAsInt( damages[ i ] ) != 0 )
            {
                if( sk > Random( 5, 95 ) )
                {
                    targetCr.SetAsInt( damages[ i ], 0 );
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_HEAL_DMG( damages[ i ] ) );
                    uninjured++;
                }
                else
                {
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NOHEAL_DMG( damages[ i ] ) );
                }
                sk /= 2;
            }
        }

        if( isPlayer )
        {
            if( uninjured > 0 )
                cr.Experience += uninjured * 50;
            cr.TimeoutSkDoctor = DOCTOR_TIMEOUT( cr );
            AddScore( cr, SCORE_DOCTOR, uninjured );
        }
    }
    break;
    case CritterProperty::SkillLockpick:
    {
        // Lockers processed in lockers.fos
    }
    break;
    case CritterProperty::SkillTraps:
    {
        // Explosion
        if( valid( targetItem ) )
        {
            hash pid = targetItem.ProtoId;
            if( ( pid == Content::Item::active_dynamite || pid == Content::Item::active_plastic_explosive || pid == Content::Item::active_mine ) &&
                OnUseExplode( cr, targetItem, null, null, null, 0 ) )
                return true;
        }

        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
    }
    break;
    default:
    {
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
    }
    break;
    }

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.
void critter_reload_weapon( Critter& cr, Item& weapon, Item@ ammo )
{
    // Special weapons
    if( weapon.Weapon_Caliber == 0 )
    {
        if( weapon.ProtoId == Content::Item::solar_scorcher )
        {
            if( IS_NIGHT( __Hour ) )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SOLAR_SCORCHER_NO_LIGHT );
            else
                weapon.AmmoCount = weapon.Weapon_MaxAmmoCount;
        }

        return;
    }

    // Other weapons
    // Unload
    if( not valid( ammo ) || ( weapon.AmmoCount > 0 && weapon.AmmoPid != ammo.ProtoId ) )
    {
        if( weapon.AmmoPid != 0 )
        {
            Item@ existAmmo = cr.GetItem( weapon.AmmoPid, -1 );
            if( not valid( existAmmo ) )
                cr.AddItem( weapon.AmmoPid, weapon.AmmoCount );
            else
                _IncItem( existAmmo, weapon.AmmoCount );
        }
        weapon.AmmoCount = 0;
    }

    // Load
    if( valid( ammo ) )
    {
        uint count = MIN( ammo.Count, weapon.Weapon_MaxAmmoCount - weapon.AmmoCount );
        weapon.AmmoCount += count;
        weapon.AmmoPid = ammo.ProtoId;
        _SubItem( ammo, count );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register/login in game or npc created/loaded.
// Default start position for players is center of global map.
void critter_init( Critter& cr, bool firstTime )
{
    if( firstTime )
    {
        if( cr.IsPlayer() )
        {
            // Input: 7 special, 3 tag skills, 2 traits, age, gender
            uint traitsCount = 0;
            for( uint i = 0; i < CritterPropertyTraits.length(); i++ )
            {
                if( cr.GetAsInt( CritterPropertyTraits[ i ] ) != 0 && traitsCount < 2 )
                    traitsCount++;
                else
                    cr.SetAsInt( CritterPropertyTraits[ i ], 0 );
            }

            if( cr.Gender < 0 || cr.Gender > 1 )
                cr.Gender = 0;
            if( cr.Age < 14 || cr.Age > 80 )
                cr.Age = 25;

            cr.StrengthBase = CLAMP( cr.StrengthBase, 1, 10 );
            cr.PerceptionBase = CLAMP( cr.PerceptionBase, 1, 10 );
            cr.EnduranceBase = CLAMP( cr.EnduranceBase, 1, 10 );
            cr.CharismaBase = CLAMP( cr.CharismaBase, 1, 10 );
            cr.IntellectBase = CLAMP( cr.IntellectBase, 1, 10 );
            cr.AgilityBase = CLAMP( cr.AgilityBase, 1, 10 );
            cr.LuckBase = CLAMP( cr.LuckBase, 1, 10 );

            if( ( cr.StrengthBase + cr.PerceptionBase + cr.EnduranceBase +
                  cr.CharismaBase + cr.IntellectBase + cr.AgilityBase + cr.LuckBase ) != __StartSpecialPoints )
            {
                cr.StrengthBase = 5;
                cr.PerceptionBase = 5;
                cr.EnduranceBase = 5;
                cr.CharismaBase = 5;
                cr.IntellectBase = 5;
                cr.AgilityBase = 5;
                cr.LuckBase = 5;
            }

            cr.EmpResistanceBase = 500;
            AddHolodiskInfo( cr, 42 );                       // Journalist's research

            // Default skin
            cr.ModelNameBase = ( cr.Gender == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
        }

        if( cr.TagSkill1 != CritterProperty::Invalid && CritterPropertySkills.find( cr.TagSkill1 ) == -1 )
            cr.TagSkill1 = CritterProperty::Invalid;
        if( cr.TagSkill2 != CritterProperty::Invalid && CritterPropertySkills.find( cr.TagSkill2 ) == -1 )
            cr.TagSkill2 = CritterProperty::Invalid;
        if( cr.TagSkill3 != CritterProperty::Invalid && CritterPropertySkills.find( cr.TagSkill3 ) == -1 )
            cr.TagSkill3 = CritterProperty::Invalid;

        dict< CritterProperty, int > props;
        for( uint i = 0; i < CritterPropertyRegProperties.length(); i++ )
            props[ CritterPropertyRegProperties[ i ] ] = cr.GetAsInt( CritterPropertyRegProperties[ i ] );
        CritterGenerate( props );
        for( uint i = 0; i < props.length(); i++ )
            cr.SetAsInt( props.getKey( i ), props.getValue( i ) );

        cr.CurrentHp = cr.MaxLife;
        cr.CurrentAp = cr.ActionPoints * AP_DIVIDER;

        if( cr.IsPlayer() )
        {
            cr.ReplicationCost = 100;
            cr.ReplicationMoney = 0;
            cr.ReplicationCount = 0;
            cr.TeamId = 1;
            cr.DamageType = DAMAGE_NORMAL;

            SetStartLocation( cr );

            // Main quest
            if( __MainStoryLineActive )
                SetPlayerStoryLineLocation( cr );
        }
        else
        {
            cr.ModelName = cr.ModelNameBase;
            if( cr.Level != 0 )
                NpcProcessLevel( cr );
        }
    }
    else
    {
        // Main quest
        if( cr.IsPlayer() && __MainStoryLineActive )
            SetPlayerStoryLineLocation( cr );

        // Current skin validation
        Item@ armor = cr.GetItem( 0, SLOT_ARMOR );
        if( not valid( armor ) )
        {
            uint modelName = cr.ModelNameBase;
            if( modelName == 0 )
                modelName = ( cr.Gender == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
            if( cr.ModelName != modelName )
                cr.ModelName = modelName;
        }

        // Clear timeouts if too long (happens when saves got removed)
        for( uint i = 0; i < CritterPropertyTimeouts.length(); i++ )
            if( CritterPropertyTimeouts[ i ] != CritterProperty::TimeoutBattle && uint( cr.GetAsInt( CritterPropertyTimeouts[ i ] ) ) > MAXIMUM_TIMEOUT )
                cr.SetAsInt( CritterPropertyTimeouts[ i ], 0 );

        // Erase zero time events
        cr.EraseTimeEvents( 0 );

        // TRAIT_FAST_SHOT migration, delete in future
        if( cr.IsTraitFastShot )
            cr.IsNoAim = true;
    }

    if( cr.IsPlayer() )
    {
        if( cr.Kills.length() != MAX_BODY_TYPES )
        {
            uint[] kills = cr.Kills;
            kills.resize( MAX_BODY_TYPES );
            cr.Kills = kills;
        }
        if( cr.Addictions.length() !=  MAX_ADDICTIONS  )
        {
            bool[] addictions = cr.Addictions;
            addictions.resize( MAX_ADDICTIONS );
            cr.Addictions = addictions;
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.
void critter_finish( Critter& cr, bool toDelete )
{
    if( toDelete && cr.DeadBlockerId != 0 )
    {
        Item@ block = GetItem( cr.DeadBlockerId );
        if( valid( block ) )
            DeleteItem( block );
        cr.DeadBlockerId = 0;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every __CritterIdleTick time.
void critter_idle( Critter& cr )
{
    if( cr.IsDead() && cr.ReplicationTime >= 0 && !IS_TIMEOUT( cr.TimeoutReplication ) )
        ReplicateCritter( cr );

    // Healing
    if( !IS_TIMEOUT( cr.TimeoutHealing ) )
    {
        if( !cr.IsDead() && !cr.IsNoHeal && !IS_TIMEOUT( cr.TimeoutBattle ) && cr.CurrentHp < cr.MaxLife )
        {
            cr.CurrentHp += cr.HealingRate * ( cr.PerkVampireRegeneration != 0 ? 2 : 1 );
            if( cr.CurrentHp > cr.MaxLife )
                cr.CurrentHp = cr.MaxLife;
        }

        cr.TimeoutHealing = HEALING_TIMEOUT( cr );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void critter_dead( Critter& cr, Critter@ killer )
{
    // Move slot items to inventory
    Item@ hands1 = cr.GetItem( 0, SLOT_HAND1 );
    Item@ hands2 = cr.GetItem( 0, SLOT_HAND2 );
    if( hands1 !is null )
        cr.MoveItem( hands1.Id, 0, SLOT_INV );
    if( hands2 !is null )
        cr.MoveItem( hands2.Id, 0, SLOT_INV );

    // Move inventory items to ground
    Map@ map = cr.GetMap();
    if( ( cr.Anim2Dead == ANIM2_DEAD_PULSE_DUST || cr.Anim2Dead == ANIM2_DEAD_EXPLODE ) && _CritCanDropItemsOnDead( cr ) )
    {
        // Drop all, exclude armor
        Item@[] items;
        cr.GetItems( SLOT_INV, items );
        cr.GetItems( SLOT_HAND1, items );
        cr.GetItems( SLOT_HAND2, items );
        if( valid( map ) )
        {
            // Disable drop of hidden items
            for( uint i = 0, j = items.length(); i < j; i++ )
            {
                if( items[ i ].IsGag )
                {
                    Item@ item = items[ i ];
                    if( valid( item ) )
                        DeleteItem( item );
                    @items[ i ] = null;
                }
                else if( items[ i ].IsHidden )
                {
                    @items[ i ] = null;
                }
            }
            MoveItems( items, map, cr.HexX, cr.HexY );
        }
        else
        {
            DeleteItems( items );
        }
    }

    // Mob drops
    hash npcPid = cr.ProtoId;
    hash dropPid = 0;
    if( npcPid == Content::Critter::GoldenGecko || npcPid == Content::Critter::ToughGoldenGecko )
    {
        if( valid( killer ) && killer.PerkGeckoSkinning != 0 )
            dropPid = Content::Item::golden_gecko_pelt;
    }
    else if( npcPid == Content::Critter::SmallSilverGecko || npcPid == Content::Critter::ToughSilverGecko )
    {
        if( valid( killer ) && killer.PerkGeckoSkinning != 0 )
            dropPid = Content::Item::gecko_pelt;
    }
    else if( npcPid == Content::Critter::SmallRadscorpion || npcPid == Content::Critter::SmallRadscorpion2 ||
             npcPid == Content::Critter::LargeRadscorpion || npcPid == Content::Critter::LargeRadscorpion2 ||
             npcPid == Content::Critter::LargeRadscorpion3 )
    {
        dropPid = Content::Item::scorpion_tail;
    }
    else if( npcPid == Content::Critter::Brahmin || npcPid == Content::Critter::Brahmin2 ||
             npcPid == Content::Critter::Brahmin3 || npcPid == Content::Critter::WeakBrahmin ||
             npcPid == Content::Critter::WildBrahmin )
    {
        if( valid( killer ) && killer.PerkGeckoSkinning != 0 )
            dropPid = Content::Item::brahmin_skin;
    }
    else if( npcPid == Content::Critter::GiantBeetle || npcPid == Content::Critter::GiantBeetle_2 )
    {
        if( Random( 1, 3 ) == 3 )
            dropPid = Content::Item::radscorpion_parts;
    }

    if( dropPid != 0 && _CritCountItem( cr, dropPid ) == 0 )
        _CritAddItem( cr, dropPid, 1 );

    // Karma, temporary
    if( valid( killer ) && killer.IsPlayer() )
    {
        int  karmaBefore = killer.Karma;
        uint team = cr.TeamId;
        if( team == TEAM_Poorman )
            killer.Karma -= 10;
        else if( team == TEAM_Narcoman )
            killer.Karma += 10;
        else if( team == TEAM_Citizen )
            killer.Karma -= 10;
        else if( team == TEAM_Guard )
            killer.Karma -= 10;
        else if( team == TEAM_PrivateGuard )
            killer.Karma -= 10;
        else if( team == TEAM_Trader )
            killer.Karma -= 10;
        else if( team == TEAM_Bandit )
            killer.Karma += 10;
        else if( team == TEAM_CasinoPlayer )
            killer.Karma -= 10;
        else if( team == TEAM_CityElite )
            killer.Karma -= 30;
        else if( team == TEAM_QuestNpc )
            killer.Karma -= 30;
        else if( team == TEAM_Police )
            killer.Karma -= 10;
        else if( team == TEAM_Slaver )
            killer.Karma += 10;
        else if( team == TEAM_Slave )
            killer.Karma -= 10;
        else if( team == TEAM_Trapper )
            killer.Karma -= 10;

        if( cr.BodyType == BT_CHILDREN )
            killer.KarmaPerkChildkiller += 1;

        CallTownSupply( cr, killer );      // Town supply call
    }

    SetReplicationTime( cr );
    if( cr.IsNpc() )
        cr.DropPlanes();                // Delete all planes
    if( valid( map ) && cr.IsNoFlatten )
    {
        Item@ blocker = map.AddItem( cr.HexX, cr.HexY, Content::Item::unvisible_block, 1 );
        if( valid( blocker ) )
            cr.DeadBlockerId = blocker.Id;
    }
    OnCritterKilled( cr, killer );
	//R17 Доп. события
	Critter@[] npcs;
    if( cr.GetCritters( false, FIND_LIFE_AND_KO | FIND_ONLY_NPC, npcs ) > 0 )
    {
		for( uint i = 0; i < npcs.length(); i++ )
        {
            Critter@ npc = npcs[ i ];
			if(valid(npc))
				__EventCritterSomeCritterDead.Raise(npc, cr, killer);
        }
	}
	//R17
	if(valid(map))
		__EventMapCritterDead.Raise(map, cr, killer);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn( Critter& cr )
{
    if( cr.DeadBlockerId != 0 )
    {
        Item@ block = ::GetItem( cr.DeadBlockerId );
        if( valid( block ) )
            DeleteItem( block );
        cr.DeadBlockerId = 0;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter in to map.
void map_critter_in( Map& map, Critter& cr )
{
    OnCitterMapIn( cr, map );
    if( cr.IsPlayer() )
        PlaceLoot2Container( map, cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
//void map_critter_out( const Map& map, const Critter& cr )
void map_critter_out( Map& map, Critter& cr )
{
    OnCritterMapOut( cr, map );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting( Critter& crFrom, Critter& crTo, bool valUp )
{
    // Players karma system (not used)
    crTo.PlayerKarma += ( valUp ? int(5) : -10 );
    crFrom.TimeoutKarmaVoting = __FullSecond + REAL_HOUR( 4 ); // 4 hours
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of critters.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
// Return true to allow see one critter another, false to disallow.
// Note: CRITTER_EVENT_SHOW_CRITTER_X, CRITTER_EVENT_HIDE_CRITTER_X is not processed.
bool check_look( const Map& map, const Critter& critter, const Critter& target )
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of items with ITEM_TRAP flag.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
bool check_trap_look( const Map& map, const Critter& critter, const Item& item )
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter( Item@[]& saleItems, uint[]& saleItemsCount, Item@[]& buyItems, uint[]& buyItemsCount, Critter& player, Critter& npc )
{
    if( npc.IsBarterOnlyCash )
    {
        for( uint i = 0, j = saleItems.length(); i < j; i++ )
        {
            Item@ item = saleItems[ i ];
            if( valid( item ) && item.ProtoId != Content::Item::bottle_caps )
            {
                npc.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_BARTER_ONLY_CASH );
                npc.SayMsg( SAY_DIALOG, TEXTMSG_GAME, STR_BARTER_ONLY_CASH );
                return false;
            }
        }
    }

    if( !BarterAllowed( npc.Id, buyItems, saleItems ) )
    {
        npc.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_BARTER_ITEM_NOT_ALLOWED );
        return false;
    }

    return true;
}

// Call on world saving
// Range of currentIndex: 1..9999
void world_save( uint currentIndex, uint[]& deleteIndexes )
{
    // Keep only current and four last saves
    if( currentIndex == 1 )
    {
        deleteIndexes.resize( 5 );
        for( uint i = 0; i < 5; i++ )
            deleteIndexes[ i ] = 9999 - i;
    }
    else if( currentIndex > 4 )
    {
        deleteIndexes.resize( 1 );
        deleteIndexes[ 0 ] = currentIndex - 5;
    }
    // bboards
    SaveMessengerData();
}

// Call on player try register
// Return true to allow, false to disallow
bool player_registration( uint ip, string& name, uint& textMsg, uint& strNum, string& lexems )
{
    uint nameError = CheckPlayerName( name );
    if( nameError != 0 )
    {
        textMsg = TEXTMSG_GAME;
        strNum = nameError;
        return false;
    }
    return true;
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login( uint ip, string& name, uint id, uint& textMsg, uint& strNum, string& lexems )
{
    if( __PermanentDeath > 0 && IsPermanentDeath( id ) )
    {
        textMsg = TEXTMSG_GAME;
        strNum = STR_NET_PERMANENT_DEATH;
        return false;
    }
    return true;
}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess( Critter& player, int access, string& password )
{
    Log( "Access changed for player " + player.Name + ", from " + player.GetAccess() + " to " + access + "." );
    return true;
}

bool player_allowcommand( Critter@ player, string@ adminPanel, uint8 command )
{
    if( valid( adminPanel ) )
        return true;

    switch( command )
    {
    // ACCESS_CLIENT
    case COMMAND_CHANGE_PASSWORD:
    case COMMAND_DELETE_ACCOUNT:
    case COMMAND_EXIT:
    case COMMAND_GETACCESS:
    case COMMAND_MYINFO:
        return true;
    // ACCESS_TESTER
    case COMMAND_DROP_UID:
    case COMMAND_PARAM:
    case COMMAND_TOGLOBAL:
        if( player.GetAccess() >= ACCESS_TESTER )
            return true;
        break;
    // ACCESS_MODER
    case COMMAND_ADDITEM:
    case COMMAND_ADDITEM_SELF:
    case COMMAND_ADDLOCATION:
    case COMMAND_ADDNPC:
    case COMMAND_BAN:
    case COMMAND_CHECKVAR:
    case COMMAND_CRITID:
    case COMMAND_DISCONCRIT:
    case COMMAND_GAMEINFO:
    case COMMAND_KILLCRIT:
    case COMMAND_MOVECRIT:
    case COMMAND_RESPAWN:
    case COMMAND_SETVAR:
        if( player.GetAccess() >= ACCESS_MODER )
            return true;
        break;
    // ACCESS_ADMIN
    case COMMAND_RELOAD_PROTOS:
    case COMMAND_LOADDIALOG:
    case COMMAND_LOADSCRIPT:
    case COMMAND_LOG:
    case COMMAND_RELOAD_CLIENT_SCRIPTS:
    case COMMAND_RELOADAI:
    case COMMAND_RELOADDIALOGS:
    case COMMAND_RELOADSCRIPTS:
    case COMMAND_RELOADTEXTS:
    case COMMAND_REGENMAP:
    case COMMAND_RUNSCRIPT:
    case COMMAND_SETTIME:
        if( player.GetAccess() == ACCESS_ADMIN )
            return true;
        break;
    // Unknown command
    default:
        player.Say( SAY_NETMSG, "Unknown command." );
        return false;
    }

    player.Say( SAY_NETMSG, "Access denied." );
    return false;
}

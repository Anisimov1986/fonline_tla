// FOS Server
// Author: cvet
// For test reasons, can be exluded in any time

#include "Tla"

void test( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    if( not valid( map ) )
        return;
    Item@ car = map.AddItem( p0, p1, Content::Item::hummer, 1 );
    car.IsGeck = true;
}

void test1( Critter& cr, int p0, int p1, int p2 )
{
    cr.Say( SAY_NORM, "русские буквы АБВгДееейёёёё!" );
}

class Example
{
    int    a;
    int8   b;
    uint16 c;
    uint64[] arr;
    string str;
}

void zero( Critter& cr, int p0, int p1, int p2 )
{
//	float timeout = 2.0f;
//	float factor = 0.5f;
    float t = 1.0f / 0.9f;
    cr.Say( SAY_NETMSG, "!!!!!!!!!!!!!!" );
}

void test4( Critter& cr, int p0, int p1, int p2 )
{
    uint16 year = 0;
    uint16 month = 0;
    uint16 day_of_week = 0;
    uint16 day = 0;
    uint16 hour = 0;
    uint16 minute = 0;
    uint16 second = 0;
    GetGameTime( __FullSecond, year, month, day, day_of_week, hour, minute, second );
    uint   fm = GetFullSecond( year, month, day, hour, minute, second );

    Log( "Real: " + "FullSecond " + __FullSecond + " Year " + __Year + " Month " + __Month + " Day " + __Day + " Hour " + __Hour + " Minute " + __Minute + " Second " + __Second );
    Log( "Calc: " + "FullSecond " + fm + " Year " + year + " Month " + month + " Day " + day + " Hour " + hour + " Minute " + minute + " Second " + second + " DayOfWeek " + day_of_week );
}

void answer_Generic( Critter& player, uint answerI, string& answerS )
{
    player.Say( SAY_NETMSG, "Answer integer<" + answerI + ">, string<" + answerS + ">." );
}

void elevator( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_ELEVATOR, ELEVATOR_BOS_1234( p0 ), "answer_Generic" );
}

void dlgbox( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_DIALOGBOX, 5, "answer_Generic" );
    cr.Say( SAY_DIALOGBOX_TEXT, "Choose you button dude." );
    cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Button0" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Button1" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "Button2" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "Button3" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), "Button4" );
}

void skillbox( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_SKILLBOX, 0, "answer_Generic" );
}

void say( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_SAY, p0, "answer_Generic" );
    cr.Say( SAY_SAY_TITLE, "Choose you..." );
    cr.Say( SAY_SAY_TEXT, "sometext" );
}

void timer( Critter& cr, int p0, int p1, int p2 )
{
    const Item@ proto = GetProtoItem( Content::Item::bottle_caps );
    cr.ShowScreen( SCREEN_TIMER, proto.PicInv, "answer_Generic" );
}

void bag( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_BAG, 0, "answer_Generic" );
}

void inventory( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_INVENTORY, 0, "" );
}

void cha( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CHARACTER, 0, "" );
}

void fixboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_FIXBOY, 0, "" );
}

void pipboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_PIPBOY, 0, "" );
}

void minimap( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_MINIMAP, 0, "" );
}

void close( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CLOSE, 0, "" );
}









// ok, just predictable log message about null pointer exception
// string@ SomeFunc(string& str)

// results in ICE: Assertion failed: tempVariables.GetLength() == 0, file ..\..\source\as_compiler.cpp, line 611
// string SomeFunc(string& str)

// crash
/*string SomeFunc(string& str)
   {
        string@[]@ forms = split(str, " ");
           // uncomment to reproduce crash
        // SomeFunc1(forms);
        return null;
   }

   void SomeFunc1(string@[]@ arr)
   {
        Log("Ok");
   }*/

void DLog( string& str )
{
    Log( str );
}

// ent number for i-th room
// global value, but we can change it to be different per-npc
#define ENT    # (i)        ( 50 + i )



class SomeClassA
{
    int A;

    ~SomeClassA()
    {
        Log( "destruct" );
    }
}

class SomeClassB
{
    SomeClassA@ nullptr;
    SomeClassB( SomeClassA@ aPtr )
    {
        nullptr.A = 100;       // Null pointer access, but after this class a is destroyed
    }
}

void test10( Critter& crit, int p0, int p1, int p2 )
{
    SomeClassA a;
    SomeClassB( a );
}
/*
   void test11(Critter& cr, int p0, int p1, int p2)
   {
        Critter@ npc=GetCritter(uint(p0)+5000000);
        if(not valid(npc)) return;

        npc.SetEvent(CRITTER_EVENT_PLANE_BEGIN,"_Begin");
        npc.SetEvent(CRITTER_EVENT_PLANE_END,"_End");

        NpcPlane@ plane=CreatePlane();
        plane.Type=AI_PLANE_WALK;
        plane.Priority=0;
        plane.Walk_HexX=p1;
        plane.Walk_HexY=p2;
        plane.Walk_Run=false;
        plane.Walk_Cut=0;

        NpcPlane@ plane2=CreatePlane();
        @plane.Child=plane2;
        plane2.Type=AI_PLANE_WALK;
        plane2.Priority=0;
        plane2.Walk_HexX=p1+10;
        plane2.Walk_HexY=p2;
        plane2.Walk_Run=false;
        plane2.Walk_Cut=0;

        npc.AddPlane(plane);
   }*/

void _Begin( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "Begin, reason: " + reason + "." );
}

void _End( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "End, reason: " + reason + "." );
}

void test12( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;

    AddWalkPlane( npc, 2, cr.HexX, cr.HexY, cr.Dir, false, 2 );
    AddMiscPlane( npc, 1, __FullSecond + 3 * 60, null );
}

void plane_Misc( Critter& npc )
{
    npc.Say( SAY_NORM, "Ho-ho-ho." );
}


void test13( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    Log( "begin" );
    if( map.Reload() )
        Log( "ok" );
}

void test14( Critter& cr, int p0, int p1, int p2 )
{
    Map@ location = cr.GetMap();
    Log( "begin loc" );
    if( location.Reload() )
        Log( "ok" );
}

void test15( Critter& cr, int p0, int p1, int p2 )
{
    cr.RunClientScript( "__Test", p0, p1, p2, null, null );
}

void test17( Critter& cr, int p0, int p1, int p2 )
{
    Log( "Show callback." );
}

void testGroup( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;
    Critter@ npc2 = GetCritter( uint( p1 ) + 5000000 );
    if( not valid( npc2 ) )
        return;

    Critter@[] group( 2 );
    @group[ 0 ] = npc;
    @group[ 1 ] = npc2;

    cr.TransitToGlobal( group );
}

void testFly( Critter& cr, int p0, int p1, int p2 )
{
    Log( "x " + cr.HexX + " y " + cr.HexY );
    cr.GetMap().RunFlyEffect( p0, null, null, cr.HexX, cr.HexY, p1, p2 );
}

void testDelItem( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cl = GetCritter( uint( p0 ) );
    if( not valid( cl ) )
        return;
    DeleteItem( cl.GetItem( 0, p1 ) );
}

void testSwap( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cr1 = GetCritter( uint( p0 ) );
    Critter@ cr2 = GetCritter( uint( p1 ) );
    SwapCritters( cr1, cr2, true );
}

void test_find( Critter& cr, int p0, int p1, int param2 )
{
    Map@ map = cr.GetMap();
    int  f = 0;
    switch( p0 )
    {
    case 0:
        f = FIND_LIFE;
        break;
    case 1:
        f = FIND_KO;
        break;
    case 2:
        f = FIND_DEAD;
        break;
    case 3:
        f = FIND_LIFE_AND_KO;
        break;
    case 4:
        f = FIND_LIFE_AND_DEAD;
        break;
    case 5:
        f = FIND_KO_AND_DEAD;
        break;
    case 6:
        f = FIND_ALL;
        break;
    }
    uint count = map.GetNpcCount( param2, f );
    for( uint i = 0; i < count; i++ )
    {
        Critter@ cow = map.GetNpc( param2, f, i );
        map.SetText( cow.HexX, cow.HexY, COLOR_RGB( 255, 0, 0 ), "" + count );
    }
    cr.Say( SAY_NORM_ON_HEAD, "" + f );
}


import void AffectRadiation( Critter& cr, int value ) from "Radiation";
import void AffectPoison( Critter& cr, int value ) from "Poison";

void testPlague( Critter& cr, int isRad, int value, int p2 )
{
    if( isRad != 0 )
        AffectRadiation( cr, value );
    else
        AffectPoison( cr, value );
    cr.Say( SAY_NETMSG, "rad " + cr.RadiationLevel );
    cr.Say( SAY_NETMSG, "psn " + cr.PoisoningLevel );
}

void LocInfo( Critter& cr, int isRad, int value, int p2 )
{
    Location@ loc = cr.GetMap().GetLocation();
    cr.Say( SAY_NETMSG, "MapPid " + cr.GetMap().ProtoId );
    cr.Say( SAY_NETMSG, "LocPid " + loc.ProtoId );
    cr.Say( SAY_NETMSG, "Hidden " + ( loc.Hidden ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckVisible " + ( loc.GeckVisible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "AutoGarbage " + ( loc.AutoGarbage ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "Radius " + loc.Radius );
}

void GetCrIds( Critter& cr, int onlyNpc, int, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Critter@[] critters;
        for( uint i = 0, j = map.GetCritters( 0, FIND_ALL | ( onlyNpc == 1 ? FIND_ONLY_NPC : 0 ), critters ); i < j; i++ )
            cr.Say( SAY_NETMSG, critters[ i ].Name + " " + critters[ i ].Id );
    }
}

void CrAddItem( Critter& cr, int crId, int pid, int count )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.AddItem( pid, count );
}

void AddExp( Critter& cr, int crId, int val, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.Experience += val;
}

/*
   import void ExplodeEx(Map& map, uint16 hexX, uint16 hexY, hash effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId) from "Explode";

   void Boom(Critter& cr, int damage, int damageRadius, int effRadius)
   {
        Map@ map=cr.GetMap();
        if(valid(map)) ExplodeEx(map,cr.HexX,cr.HexY,PID_EXPLODE_ROCKET,effRadius,damage,DAMAGE_EXPLODE,damageRadius,0);
   }
 */

void TestLoc( Critter& cr, int locPid, int count, int )
{
    for( int i = 0; i < count; i++ )
    {
        Location@ loc = GetLocation( CreateLocation( locPid, 100, 100, null ) );
        Map@      map = loc.GetMapByIndex( 0 );
        Critter@[] critters;
        uint      crCount = map.GetCritters( 0, FIND_ALL, critters );
        for( uint j = 0; j < crCount; j++ )
        {
            for( uint k = 0; k < crCount; k++ )
            {
                if( j != k )
                    AddAttackPlane( critters[ j ], 0, critters[ k ] );
            }
        }
    }
}

void TestWorld( Critter& cr, int, int, int )
{
    // 1000 locations and maps
    // 100000 items
    // 5000 npc
    for( uint i = 0; i < 1000; i++ )
        CreateLocation( 101, 100, 100, null );
}

void CrClearInv( Critter& cr, int crId, int, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        Item@[] items;
        toCr.GetItems( -1, items );
        for( uint i = 0, j = items.length(); i < j; i++ )
            DeleteItem( items[ i ] );
    }
}

void SetType( Critter& cr, int crId, int crType, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ChangeCrType( crType );
        toCr.BaseCrType = crType;
    }
}

void ChangeLook( Critter& cr, int, int, int )
{}

import void ExplodeEx( Map& map, uint16 hexX, uint16 hexY, hash effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId ) from "Explode";
void        Boom( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_LIFE_AND_KO, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
            ExplodeEx( cr.GetMap(), critters[ i ].HexX, critters[ i ].HexY, Content::Item::explode_rocket, 3, 666, DAMAGE_EXPLODE, 3, 0 );
    }
}

void Patch0( Critter& cr, int, int, int )
{
    Log( "Begin patch..." );
    Critter@[] npcs;
    GetAllNpc( 0, npcs );
    for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
        Critter@ npc = npcs[ i ];
        Map@     map = npc.GetMap();
        if( valid( map ) )
        {
            hash locPid = map.GetLocation().ProtoId;
            // if(LOCATION_IS_CITY(locPid)) npc.Refresh();
        }
    }

    Location@ locHell = GetLocationByPid( Content::Location::replication_hell, 0 );
    locHell.Reload();
    Log( "End patch." );
}

void RandomTypes( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_PLAYERS | FIND_LIFE_AND_KO, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
        {
            int type = Random( 20, 90 );
            critters[ i ].ChangeCrType( type );
            critters[ i ].BaseCrType = type;
        }
    }
}

void AllToVaultBoys( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_PLAYERS | FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
        {
            critters[ i ].ChangeCrType( 249 );
            critters[ i ].BaseCrType = 249;
        }
    }
}

void AllToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void NpcToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void AllToDead( Critter& cr, int deadType, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToDead( deadType, null );
    }
}

void ShowIds( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "My id is " + critters[ i ].Id );
}

void SetDustyScript( Critter& cr, int dustyId, int, int )
{
    Critter@ dusty = GetCritter( dustyId );
    if( valid( dusty ) )
        dusty.SetScript( "NcrDusty@_DustyInit" );
}

void TestIndex( Critter& cr, int i, int, int )
{
    cr.StrengthBase = 20;
    const int ii = cr.Strength;
    Log( "Strenght " + cr.Strength );
}

void Transit( Critter& cr, int hx, int hy, int )
{
    cr.TransitToHex( hx, hy, 6 );
}

void GlobalCar( Critter& iam, int crId, int, int )
{
    Critter@ cr = ::GetCritter( crId );
    if( valid( cr ) )
    {
        Item@[] items;
        cr.GetItemsByType( ItemType::Car, items );
        for( uint i = 0; i < items.length(); i++ )
        {
            Item@ car = items[ i ];
            car.Charge = car.Car_TankVolume;
            car.Deterioration = 0;
            iam.Say( SAY_NETMSG, "Done." );
        }
    }
}

void AddHellTurret( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ turret = map.AddNpc( Content::Critter::AutoCannon, hx, hy, iam.Dir, null, null );
    turret.SetScript( "ReplicationHell@_TurretInit" );
}

uint NpcCrazyId = 0;
void NpcCrazyEvent( Critter& cr, int off, int, int )
{
    if( off != 0 )
        CancelDeferredCall( NpcCrazyId );
    else
        NpcCrazyId = DeferredCall( 0, NpcCrazy, array< uint > = { cr.GetMap().Id } );
}

void NpcCrazy( uint[]& values )
{
    Map@ map = GetMap( values[ 0 ] );
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@[] players;
        map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, players );
        for( uint l = 0, m = players.length(); l < m; l++ )
            AddAttackPlane( critters[ i ], 0, players[ l ] );
    }
    NpcCrazyId = DeferredCall( Random( 10, 40 ) * 1000, NpcCrazy, values );
}

void AddMadRobot( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ turret = map.AddNpc( Content::Critter::AutoCannon, hx, hy, iam.Dir, null, null );
    turret.TeamId = 19;
    turret.SetScript( "ReplicationHell@_TurretInit" );
//	turret.SetStat(ST_REPLICATION_TIME,1);
//	turret.SetPerk(PE_TERMINATOR,1);
    turret.AddItem( Content::Item::heavy_dual_minigun, 2 );
}

void AllNpcSetParam( Critter& cr, int index, int value, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].SetAsInt( CritterProperty( index ), value );
}

void AddGuard( Critter& cr, int, int, int )
{
    int[] params = { CritterProperty::DialogId, 2200, CritterProperty::TeamId, 5 };
    Critter@ guard = cr.GetMap().AddNpc( Content::Critter::HubologistGuard, cr.HexX, cr.HexY - 1, 2, params, "MapBarterGround@_GuardInit" );
    guard.AddItem( Content::Item::end_boss_plasma_gun, 3 );
}

void NpcFullDead( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ReplicationTime = -1;
        critters[ i ].ToDead( 1, null );
    }
}

void NpcReturn( Critter& cr, int replTime, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ReplicationTime = replTime;
        critters[ i ].ToLife();
    }
}

const hash[] pids = { Content::Critter::MaleOrphan, Content::Critter::FemaleOrphan, Content::Critter::HealthyFemaleSlave, Content::Critter::HealthyMaleSlave, Content::Critter::HealthyFemaleSlave, Content::Critter::HealthyMaleSlave, Content::Critter::HealthyFemaleSlave, Content::Critter::HealthyMaleSlave, Content::Critter::MaleOrphan, Content::Critter::FemaleOrphan, Content::Critter::HealthyFemaleSlave, Content::Critter::HealthyMaleSlave, Content::Critter::AverageMerchantMale, Content::Critter::WeakMeleeGuardMale, Content::Critter::RaiderMale, Content::Critter::RaiderFemale };

void AddHostile( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ hostile = map.AddNpc( pids[ Random( 0, pids.length() - 1 ) ], hx, hy, iam.Dir, null, null );
    hostile.TeamId = 19;
    // hostile.SetStat(ST_REPLICATION_TIME,Random(5,10));
    DeferredCall( 0, HostileMove, hostile.Id );
}

uint SufferingLastTime = 0;
void HostileMove( uint value )
{
    Critter@ hostile = GetCritter( value );
    if( not valid( hostile ) )
        return;

    if( hostile.IsLife() )
    {
        hostile.MoveRandom();

        if( __FullSecond > SufferingLastTime )
        {
            string say;
            switch( Random( 0, 50 ) )
            {
            case 0:
                say = "Малые страдания выводят нас из себя, великие же - возвращают нас самим себе.";
                break;
            case 1:
                say = "Минутное удовольствие часто бывает причиной долгих страданий. ";
                break;
            case 2:
                say = "Кто боится страдания, тот уже страдает от боязни.";
                break;
            case 3:
                say = "Язвы желудка возникают не от того, что вы едите, а от того, что съедает вас. ";
                break;
            case 4:
                say = "Бедное раздавленное насекомое страдает так же, как умирающий гигант. ";
                break;
            case 5:
                say = "Молчание - величайшее из человеческих страданий; святые никогда не молчали. ";
                break;
            case 6:
                say = "Раны, нанесенные собственной рукой, всегда заживают медленнее, чем те, которые нанес противник. ";
                break;
            case 7:
                say = "Не умеешь нести бремя невзгод - усугубляешь их тяжесть. ";
                break;
            case 8:
                say = "Есть два способа преодолевать трудности: либо вы изменяете сами трудности, чтобы было легче с ними справится, либо, справляясь с ними изменяетесь сами. ";
                break;
            case 9:
                say = "Если мы еще можем любить тех, кто заставил нас страдать, то любовь наша лишь становится сильнее.  ";
                break;
            case 10:
                say = "Мужественный человек обыкновенно страдает, не жалуясь, человек же слабый жалуется, не страдая.";
                break;
            case 11:
                say = "Величайшее зло - страдание.";
                break;
            case 12:
                say = "Всеми страданиями вокруг нас должны страдать и мы. У всех у нас не одно тело, но одно развитие, а это проводит нас через все боли в той или иной форме. Как дитя проходит в своем развитии через все стадии жизни вплоть до старости и до смерти (и каждая стадия, в сущности, от страха или от желания, кажется предыдущей недостижимою), точно так же и мы (связанные с человечеством не менее глубоко, чем с самими собой) проходим в своем развитии через все страдания этого мира. Справедливости при таком положении нет места, но нет места и страху перед страданием или возможности истолковать страдание как заслугу.";
                break;
            case 13:
                say = "Издевательство над чужими страданиями не должно быть прощаемо.";
                break;
            case 14:
                say = "К величию есть только один путь, и этот путь проходит через страдания.";
                break;
            case 15:
                say = "Когда мне не дают роли, чувствую себя пианисткой, которой отрубили руки.";
                break;
            case 16:
                say = "Мы стремимся в большей степени к тому, чтобы отвести от себя страдания, нежели к тому, чтобы получить удовольствие.";
                break;
            case 17:
                say = "Обусловленное существование есть страдание. У страдания есть причина. У страдания есть конец, и есть пути, ведущие к этому концу.";
                break;
            case 18:
                say = "Только здесь страдать – это страдать. Не в том смысле, что те, кто страдает здесь, где-то в другом месте из-за этого страдания будут возвышенны, а в том смысле, что то, что именуется в этом мире страданием, в другом мире не изменяется, а только освобождено от своей противоположности, блаженства.";
                break;
            case 19:
                say = "Ты можешь отстраняться от страданий мира, это тебе разрешается и соответствует твоей природе, но, быть может, как раз это отстранение и есть единственное страдание, которого ты мог бы избежать.";
                break;
            case 20:
                say = "Человеческий разум может излечить от иллюзий, но не от страданий.";
                break;
            case 21:
                say = "Чем больше любят, тем больше страдают. Вся возможная для каждой души боль пропорциональна степени ее совершенства.";
                break;
            case 22:
                say = "Мудрый не горюет о потерянном, об умершем и о прошлом. Тем он отличается от глупца.";
                break;
            case 23:
                say = "Размышляй об изгнании, пытках, войнах, болезнях, кораблекрушениях, чтобы не быть новичком ни при каких бедствиях.";
                break;
            case 24:
                say = "Подлинное душевное спокойствие достигается примирением с самым худшим.";
                break;
            case 25:
                say = "Кто страдает раньше, чем это необходимо, тот страдает больше необходимого.";
                break;
            case 26:
                say = "Кто боится страданий, тот уже страдает от боязни.";
                break;
            case 27:
                say = "Ничтожным не бывает то, что больно нам.";
                break;
            case 28:
                say = "Моря человеческих слез не были бы так огромны, если бы не были бы так мелки.";
                break;
            case 29:
                say = "Чувствительный человек – точно безоружный среди хорошо вооруженных.";
                break;
            case 30:
                say = "Люди не бывают очень несчастны, если им не в чем раскаиваться.";
                break;
            case 31:
                say = "Чужие бедствия могут быть поводом к безропотности, но не к утешению.";
                break;
            case 32:
                say = "Огорчение существует не само по себе, а в нашем представлении.";
                break;
            case 33:
                say = "Мы созданы для несчастий. Слезы для сердца, что вода для рыб.";
                break;
            case 34:
                say = "В этом мире самым надежным развлечением для нас являются тревоги и страдания.";
                break;
            case 35:
                say = "Наш мир есть ничто иное, как скопление громадных страданий.";
                break;
            case 36:
                say = "Горечь – единственное накопление человека в жизни.";
                break;
            case 37:
                say = "Единственный способ быть счастливым – это любить страдания.";
                break;
            case 38:
                say = "В жизни, как и в природе, бывает гораздо больше пасмурных дней, чем безоблачных.";
                break;
            case 39:
                say = "Не чувствовать страданий не свойственно человеку, а не уметь их переносить не подобает мужчине.";
                break;
            case 40:
                say = "Ни с кем не случается ничего такого, что он не в силах был бы вынести.";
                break;
            case 41:
                say = "Мужайтесь и храните себя для благоприятных времен.";
                break;
            case 42:
                say = "Переноси с достоинством то, что изменить не сможешь.";
                break;
            case 43:
                say = "Кто переносит нетерпеливо, тот страдает вдвойне.";
                break;
            case 44:
                say = "Слезы для женщины – облегчение, для мужчины – пытка.";
                break;
            case 45:
                say = "Хочешь быть счастливым – выучись сперва страдать.";
                break;
            default:
                break;
            }
            if( say != "" )
                hostile.Say( SAY_NORM, say );
            SufferingLastTime = __FullSecond + Random( 3, 6 ) * 60;
        }
        else if( Random( 0, 100 ) == 0 )
            ExplodeEx( hostile.GetMap(), hostile.HexX, hostile.HexY, Content::Item::explode_rocket, 10, 666, DAMAGE_EXPLODE, 10, 0 );
    }

    SavedDeferredCall( Random( 10000, 20000 ), HostileMove, value );
}

void AttackTurret( Critter& cr, int, int, int )
{
    Critter@ turret;
    Map@     map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].ProtoId == 480 )
        {
            @turret = critters[ i ];
            break;
        }

    }

    critters.clear();
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].ProtoId != 480 )
        {
            AddAttackPlane( critters[ i ], 100, turret );
        }
    }
}


void TurretFrags( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].ProtoId == 480 )
        {
            DeferredCall( 0, HostileMove, critters[ i ].Id );
            break;
        }
    }
}

void TurretParam( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].BonusLook = 1000;
    }
}

void CreateCar( Critter& cr, int pid, int ox, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX + ox, cr.HexY + oy, pid, 1 );
    if( not valid( car ) || car.Type != ItemType::Car )
        return;

    car.Charge = car.Car_TankVolume;
    car.Deterioration = 0;

    uint keyId = Random( 10000, 50000 );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;
    cr.AddItem( Content::Item::blue_pass_key, 1 ).LockerId = keyId;

    cr.Say( SAY_NETMSG, "Done." );
}

void CreateCarPersonal( Critter& cr, int pid, int crId, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX, cr.HexY + oy, pid, 1 );
    if( not valid( car ) || car.Type != ItemType::Car )
        return;

    car.Charge = car.Car_TankVolume;
    car.Deterioration = 0;
    car.CarIsNoLockpick = true;

    uint keyId = _CritEyesDoorId( crId );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;

    cr.Say( SAY_NETMSG, "Done." );
}

void AllTo3d( Critter& cr, int, int, int )
{
    Critter@[] critters;
    cr.GetMap().GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        int rnd = Random( 290, 316 );
        critters[ i ].ChangeCrType( rnd );
        critters[ i ].BaseCrType = rnd;
    }
}

void TestLexem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
        item.Lexems = "test test test";
}

class Prop
{
    void set_Test( uint value ) {}
    uint get_Test() const       { return 0; }
};
void TestProp( Critter& cr, int, int, int )
{
    Prop p;
    uint i = ( p.Test - 1 );
}

void TestScriptTimeout( Critter& cr, int, int, int )
{
    Test2();
}
void Test2()
{
    Test3();
}
void Test3()
{
    int ggg = 1;
    do
    {
        ggg = Random( 1, 100 );
    }
    while( ggg != 0 );
}

void TestNullptr( Critter&, int, int, int )
{
    Critter@ cr;
    Log( "begin" );
    uint     id = cr.Id;
    Log( "end" );
}

// Synchronizer TestLocker;
void TestScriptConcurrent( Critter& cr, int test, int, int )
{
    // TestLocker.Lock();

    Synchronize();
    Map@ map = cr.GetMap();
    Resynchronize();

    if( test == 1 )
        Resynchronize();             // Invalid call
    else if( test == 2 )
        Synchronize();               // Call without Resynchronize

    if( test == 5 )
    {
        for( int i = 0; i < 1000; i++ )
            DeferredCall( 0, TestScriptConcurrent );
    }
}

int Data = 0;
void TestScriptConcurrent()
{
    // TestLocker.Lock();

    if( Data == 0 )
        Data++;
    else if( Data == 1 )
        Data--;
    else
        Log( "Fail!" );

    DeferredCall( 1, TestScriptConcurrent );
}

void TestLog( Critter& cr, int, int, int )
{
    for( uint i = 0; i < 10000; i++ )
        Log( "Test message " + i );
}

void TestMapLoop( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetEvent( MAP_EVENT_LOOP_3, "_MapLoopEvent" );
    map.SetLoopTime( 3, 1000 );
    Log( "ok" );
}

void _MapLoopEvent( Map& map )
{
    Log( "_MapLoopEvent " + map.Id );
}

void patchBunker( Critter& cr, int, int, int )
{
    Location@ loc = GetLocationByPid( 21, 0 );    // LOCATION_TechBunker(21)
    if( @loc != null )
    {
        uint locId = loc.Id;
        DeleteLocation( locId );
        cr.Say( 11, "Location deleted. Id" + locId );     // SAY_NETMSG (11)
    }

    uint id = CreateLocation( 21, 1000, 1397, null );
    if( id == 0 )
        return;

    @ loc = GetLocation( id );
    if( @loc == null )
        return;

    loc.Hidden = true;
    loc.GeckVisible = false;
    loc.AutoGarbage = false;
    loc.Radius = 6;
}

import void ClearPermanentDeath() from "Replication";
void        ClearPermanentDeath( Critter& cr, int, int, int )
{
    ClearPermanentDeath();
}

void TestBlockItem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetMap().AddItem( cr.HexX, cr.HexY, Content::Item::radio, 1 );
    item.SetEvent( ITEM_EVENT_SKILL, "_ChangeMode" );
    item.IsNoBlock = false;
}

bool _ChangeMode( Item& item, Critter& cr, CritterProperty skill )
{
    item.IsNoBlock = !item.IsNoBlock;
    return false;
}

void DeleteTimeEvent( Critter& cr, int id, int, int )
{
    CancelDeferredCall( uint( id ) );
}

void HandToGround( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
        ::MoveItem( item, 0, cr.GetMap(), cr.HexX, cr.HexY );
}

void PatchItemFlags( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
    {
        Item@ item = items[ i ];
        bool  canPickUp = false;
        switch( item.Type )
        {
        case ItemType::Armor:
        case ItemType::Drug:
        case ItemType::Weapon:
        case ItemType::Ammo:
        case ItemType::Misc:
        case ItemType::Key:
            canPickUp = true;
            break;
        // case Misc_EX:
        case ItemType::Container:
            canPickUp = item.IsCanPickUp;
            break;
        case ItemType::Door:
            item.IsNoHighlight = true;
            break;
        default:
            break;
        }
        switch( item.ProtoId )
        {
        case 148:
        case 150:
        case 154:
        case 156:
        case 850:
        case 851:
        case 852:
        case 854:
        case 855:
        case 856:
        case 857:
        case 858:
        case 859:
        case 860:
        case 861:
        case 862:
        case 863:
        case 864:
        case 865:
        case 866:
        case 867:
        case 868:
        case 869:
        case 870:
        case 871:
        case 872:
            canPickUp = false;
            break;
        default:
            break;
        }
        if( canPickUp )
            item.IsCanPickUp = true;
        else
            item.IsCanPickUp = false;
    }
}

void ColorizeHandItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightIntensity = Random( 30, 80 );
        item.LightColor = ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        item.LightDistance = ( dist != 0 ? dist : Random( 5, 15 ) );
        item.LightFlags = 0;

        if( ( flags % 10 ) == 1 )
        {
            _LightSetIgnoreDir( item, 0 );
            _LightSetIgnoreDir( item, 2 );
            _LightSetIgnoreDir( item, 4 );
        }
        else if( ( flags % 10 ) == 2 )
        {
            _LightSetIgnoreDir( item, 1 );
            _LightSetIgnoreDir( item, 3 );
            _LightSetIgnoreDir( item, 5 );
        }
        if( ( flags / 10 ) == 1 )
            _LightSetInverse( item );

        item.IsLight = true;
    }
}

void ColorizeHandItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        item.IsColorize = true;
    }
}

void ColorizeLegsItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
}

void ColorizeLegsItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
        item.IsColorize = !item.IsColorize;
}

void PatchLight( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
    {
        Item@ item = items[ i ];
        if( item.LightIntensity != 0 || item.LightIntensity != 0 )
            item.IsLight = true;
    }
}

void CheckAccess( Critter& cr, int, int, int )
{
    Map@[] maps;
    uint mapsCount = ::GetAllMaps( 0, maps );
    for( uint i = 0; i < mapsCount; i++ )
    {
        Map@ map = maps[ i ];
        Critter@[] players;
        uint count = map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, players );
        for( uint j = 0; j < count; j++ )
        {
            Critter@ player = players[ j ];
            if( player.GetAccess() > 0 )
                cr.Say( SAY_NETMSG, "Player " + player.Name + " access " + player.GetAccess() + "." );
        }
    }
    cr.Say( SAY_NETMSG, "Search complete." );
}

void Effect( Critter& cr, int radius, int, int )
{
    cr.GetMap().RunEffect( Content::Item::explode_emp, cr.HexX, cr.HexY + 10, radius );
}

void AddLoc( Critter& cr, int pid, int x, int y )
{
    if( ::CreateLocation( pid, x, y, null ) != 0 )
        cr.Say( SAY_NETMSG, "Success." );
    else
        cr.Say( SAY_NETMSG, "Fail." );
}

void DeleteNpc( Critter& cr, int crId, int, int )
{
    DeleteNpc( GetCritter( crId ) );
}

void EndTB( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.IsTurnBasedAviable = false;
    map.EndTurnBased();
}

void TestTE( Critter& cr, int set, int, int )
{
    uint num = DeferredCall( 10000, DoTestTE, array< int > = { -8 } );
    Log( "created " + num );

    uint duration = 0;
    uint[] values;
    if( GetDeferredCallData( num, duration, values ) )
    {
        Log( "get ok+ duration " + duration );
        for( uint i = 0; i < values.length(); i++ )
            Log( i + ") " + values[ i ] );
        Log( "get ok-" );
    }
}

void DoTestTE( int[]& values )
{
    Log( "DoTestTE+" );
    for( uint i = 0; i < values.length(); i++ )
        Log( i + ") " + values[ i ] );
    Log( "DoTestTE-" );
}

void DoorKey( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;
    map.MoveHexByDir( hx, hy, cr.Dir, 1 );
    Item@ door = map.GetDoor( hx, hy );
    if( not valid( door ) )
        return;
    Item@ key = cr.AddItem( Content::Item::temple_key, 1 );
    if( not valid( key ) )
        return;
    key.LockerId = door.LockerId;
}

void HandToInv( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        if( cr.MoveItem( item.Id, 0, SLOT_INV ) )
            Log( "ok" );
        else
            Log( "fail" );
    }
}

import void DropDrugEffects( Critter& cr ) from "Drugs";
void        DropDrugs( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < 10; i++ )
    {
        map.MoveHexByDir( hx, hy, iam.Dir, 1 );
        Critter@ cr = map.GetCritter( hx, hy );
        if( valid( cr ) )
        {
            DropDrugEffects( cr );
            cr.Say( SAY_NORM, "Drugs dropped." );
            break;
        }
    }
}

void ClearExplode( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    map.GetItems( Content::Item::active_dynamite, items );
    map.GetItems( Content::Item::active_plastic_explosive, items );
    map.GetItems( Content::Item::active_mine, items );

    DeleteItems( items );
}

void Sandbags( Critter& iam, int lineLen, int skipLen )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    hash   pid = Content::Item::sandbag_empty;
    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < uint( lineLen ); i++ )
    {
        if( skipLen != 0 )
            skipLen--;
        else
        {
            map.MoveHexByDir( hx, hy, iam.Dir, 1 );
            map.AddItem( hx, hy, pid, 1 );
        }
    }
}

void ClearItems( Critter& iam, int lineLen, int skipLen, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < uint( lineLen ); i++ )
    {
        if( skipLen != 0 )
            skipLen--;
        else
        {
            map.MoveHexByDir( hx, hy, iam.Dir, 1 );
            map.GetItems( hx, hy, items );
        }
    }

    DeleteItems( items );
}

import void PlayMusic( Map& map, string& musicName, uint pos, uint repeat ) from "Media";
void        BattleMusic( Critter& iam, int index, int, int )
{
    if( index == 1 )
        PlayMusic( iam.GetMap(), "02 - Into The Dust.ogg", 0, 0 );
    else if( index == 2 )
        PlayMusic( iam.GetMap(), "07 - Echelon.ogg", 0, 0 );
    else if( index == 3 )
        PlayMusic( iam.GetMap(), "11 - Face To Face.ogg", 0, 0 );
    else if( index == 4 )
        PlayMusic( iam.GetMap(), "16 - Stranglet.ogg", 0, 0 );
    else if( index == 5 )
        PlayMusic( iam.GetMap(), "17 - Trinity.ogg", 0, 0 );
    else
        PlayMusic( iam.GetMap(), "01 - No Fate No Fear.ogg", 0, 0 );
}

void SetAnim1( Critter& cr, int value, int, int )
{
    cr.SetAnims( 0, value, 0 );
}

void SetWalk( Critter& cr, int time, int off, int )
{
    cr.WalkTime = time;
    cr.IsNoWalk = off != 0;
}

void SetRun( Critter& cr, int time, int off, int )
{
    cr.RunTime = time;
    cr.IsNoRun = off != 0;
}



void excep0( Critter& cr, int, int, int )
{
    Log( "excep0" );
    excep1( cr );
}
void excep1( Critter& cr )
{
    Log( "excep1" );
    int y = 100;
    excep2( 6 );
}
void excep2( int i )
{
    Log( "excep2" );
    for( int k = 0; k < 10; k++ )
        excep3();
}
void excep3()
{
    Log( "excep3" );
    int h = 0;
    int k = 10 / h;
}

void toDead( Critter& cr, int, int, int )
{
    cr.ToDead( ANIM2_DEAD_BLOODY_SINGLE, null );
}
void toLife( Critter& cr, int, int, int )
{
    cr.ToLife();
}
void toKO( Critter& cr, int, int, int )
{
    cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 1000, cr.HexX, cr.HexY );
}

/*#pragma bindfunc "bool TestScriptCallNative(string&, string&) -> fonline_test.dll TestScriptCallNative"
   void testScriptCall( Critter&, int, int, int )
   {
    if( TestScriptCallNative( "test", "double TestScriptCallAS(int v1, uint64 v2, float v3, string@ v4)" ) )
        Log( "testScriptCall success." );
    else
        Log( "testScriptCall fail." );
   }
   double TestScriptCallAS( int v1, uint64 v2, float v3, string@ v4 )
   {
    Log( "TestScriptCall: " + v1 + ", " + v2 + ", " + v3 + ", " + v4 + "." );
    return 1.234567890;
   }

   #pragma bindfunc "void StringExample() -> fonline_test.dll StringExample"
   void testStringExample( Critter&, int, int, int )
   {
    StringExample();
   }*/


void animate( Critter& cr, int anim1, int anim2, int )
{
    cr.Animate( anim1, anim2, null, true, true );
}

// FOS Server Client
// Author: cvet

#include "Tla"

#ifdef __CLIENT
import void SetChosenTabLevelUp( bool enable )  from "ChosenTabs";
#endif

#ifndef __CLIENT
import void PerkUp( Critter& cr, CritterProperty perk ) from "Perks";
import void PerkDown( Critter& cr, CritterProperty perk ) from "Perks";
#endif

#ifndef __CLIENT
void CritterSetExperience( const Critter& cr, CritterProperty prop, int& newValue )
{
    if( cr.Level >= int(__LevelCap) && not __LevelCapAddExperience )
    {
        newValue = cr.Experience;
        return;
    }

    int exp = newValue - cr.Experience;
    if( exp > 0 )
    {
        // SwiftLearner perk
        exp += exp * ( cr.PerkSwiftLearner * 5 ) / 100; // SwiftLearner perk

        // Process new experience
        if( cr.Level < int(__LevelCap) )
            DeferredCall( 0, UpdateExperienceLevel, cr.Id );
    }
}

void UpdateExperienceLevel( uint crId )
{
    Critter@ cr = GetCritter( crId );
    if( cr is null )
        return;

    while( cr.Level < int(__LevelCap) && cr.Experience >= NextLevelNeedExp( cr ) )
    {
        cr.Level += 1;

        // Skill points
        cr.UnspentSkillPoints += 5 + cr.IntellectBase * 2;

        // Skilled trait
        if( cr.IsTraitSkilled )
            cr.UnspentSkillPoints += 5;

        // Educated perk
        cr.UnspentSkillPoints += cr.PerkEducated * 2;

        // Clamp skill points
        if( cr.UnspentSkillPoints > 99 )
            cr.UnspentSkillPoints = 99;

        // Add max hp
        if( __MaxLifeLevelSoftCap == 0 || uint( cr.Level ) <= __MaxLifeLevelSoftCap )
            cr.MaxLifeBase += 2 + cr.EnduranceBase / 2 + cr.PerkLifegiver * 4;

        // Add perk
        if( ( cr.Level % ( cr.IsTraitSkilled ? 4 : 3 ) ) == 0 )
            cr.UnspentPerks = 1;
    }
}

void CritterSetPerks( const Critter& cr, CritterProperty perk, uint8& newValue )
{
    uint8 curValue = cr.GetAsInt( perk );
    DeferredCall( 0, DoPerkUpDown, array< uint > = { cr.Id, perk, MAX( newValue, curValue ) - MIN( newValue, curValue ), newValue > curValue ? 1 : 0 } );
}

void DoPerkUpDown( uint[]& values )
{
    Critter@ cr = GetCritter( values[ 0 ] );
    if( cr is null )
        return;

    CritterProperty perk = CritterProperty( values[ 1 ] );
    uint            count = values[ 2 ];
    bool            up = values[ 3 ] != 0;
    for( uint i = 0; i < count; i++ )
    {
        if( up )
            PerkUp( cr, perk );
        else
            PerkDown( cr, perk );
    }
}

void CritterSetHide( Critter& cr )
{
    cr.RefreshVisible();
}

void CritterSetFastShot( Critter& cr )
{
    cr.IsNoAim = cr.IsTraitFastShot;
}

void CritterSetKnownLocations( Critter& cr )
{
    uint[] knownLoc = cr.KnownLocations;
    hash[] knownLocPid;
    for( uint i = 0; i < knownLoc.length(); i++ )
    {
        Location@ loc = GetLocation( knownLoc[ i ] );
        if( loc !is null )
            knownLocPid.insertLast( loc.ProtoId );
    }
    cr.KnownLocProtoId = knownLocPid;
}

int NextLevelNeedExp( Critter& cr ) // Export
{
    int level = cr.Level;
    return NUMERICAL_NUMBER( level ) * 1000;
}
#endif

#ifdef __CLIENT
void CritterSetPropertyQuests( const Critter& cr, CritterProperty prop )
{
    uint str = hash( prop ) + cr.GetAsInt( prop );
    if( IsMsgStr( TEXTMSG_QUEST, str ) )
        Message( GetMsgStr( TEXTMSG_QUEST, str ) );
}

void CritterSetLevel( const Critter& cr, CritterProperty, int& newValue )
{
    if( newValue > cr.Level )
    {
        PlaySound( "LEVELUP.ACM" );
        Message( TEXTMSG_GAME, STR_GAIN_LEVELUP, FOMB_GAME );
        SetChosenTabLevelUp( true );
    }
}

void CritterSetExperience( const Critter& cr, CritterProperty, int& newValue )
{
    if( newValue > cr.Experience )
        Message( ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_GAIN_EXPERIENCE ), "VALUE", newValue - cr.Experience ), FOMB_GAME );
}

void CritterSetUnspentPerks( Critter& cr )
{
    if( cr.UnspentPerks > 0 && GUI_GetActiveScreen().Index == CLIENT_SCREEN_CHARACTER )
        ShowScreen( CLIENT_SCREEN_PERK );
}
#endif

// Parameters generation
// For server and client
// Both generation need be equal
// Input for player: 7 special, 3 tag skills, 2 traits, age, gender
// Imput for npc: data from prototype
void CritterGenerate( dict< CritterProperty, int >& props )
{
    props.setIfNotExist( StrengthBase, 0 );
    props.setIfNotExist( PerceptionBase, 0 );
    props.setIfNotExist( EnduranceBase, 0 );
    props.setIfNotExist( CharismaBase, 0 );
    props.setIfNotExist( IntellectBase, 0 );
    props.setIfNotExist( AgilityBase, 0 );
    props.setIfNotExist( LuckBase, 0 );
    props.setIfNotExist( HealingRateBase, 0 );
    props.setIfNotExist( ActionPointsBase, 0 );
    props.setIfNotExist( ArmorClassBase, 0 );
    props.setIfNotExist( SequenceBase, 0 );
    props.setIfNotExist( MeleeDamageBase, 0 );
    props.setIfNotExist( CriticalChanceBase, 0 );
    props.setIfNotExist( MaxCriticalBase, 0 );
    props.setIfNotExist( IsNoAim, 0 );
    props.setIfNotExist( MaxLifeBase, 0 );
    props.setIfNotExist( CarryWeightBase, 0 );
    props.setIfNotExist( CurrentAp, 0 );
    props.setIfNotExist( CurrentHp, 0 );
    props.setIfNotExist( Level, 0 );
    props.setIfNotExist( TagSkill1, CritterProperty::Invalid );
    props.setIfNotExist( TagSkill2, CritterProperty::Invalid );
    props.setIfNotExist( TagSkill3, CritterProperty::Invalid );
    for( uint i = 0; i < CritterPropertySkills.length(); i++ )
        props.setIfNotExist( CritterPropertySkills[ i ], 0 );
    for( uint i = 0; i < CritterPropertyPerks.length(); i++ )
        props.setIfNotExist( CritterPropertyPerks[ i ], 0 );
    for( uint i = 0; i < CritterPropertyTraits.length(); i++ )
        props.setIfNotExist( CritterPropertyTraits[ i ], 0 );
    for( uint i = 0; i < CritterPropertyResistsBase.length(); i++ )
        props.setIfNotExist( CritterPropertyResistsBase[ i ], 0 );
    for( uint i = 0; i < CritterPropertyThresholdsBase.length(); i++ )
        props.setIfNotExist( CritterPropertyThresholdsBase[ i ], 0 );

    if( props[ Level ] <= 0 )
        props[ Level ] = 1;

    if( props[ IsTraitSmallFrame ] != 0 )
        props[ AgilityBase ] = props[ AgilityBase ] + 1;
    if( props[ IsTraitBruiser ] != 0 )
        props[ StrengthBase ] = props[ StrengthBase ] + 2;
    if( props[ IsTraitGoodNatured ] != 0 )
    {
        props[ SkillFirstAid ] = props[ SkillFirstAid ] + 15;
        props[ SkillDoctor ] = props[ SkillDoctor ] + 15;
        props[ SkillSpeech ] = props[ SkillSpeech ] + 15;
        props[ SkillBarter ] = props[ SkillBarter ] + 15;
        props[ SkillSmallGuns ] = props[ SkillSmallGuns ] - 10;
        props[ SkillBigGuns ] = props[ SkillBigGuns ] - 10;
        props[ SkillEnergyWeapons ] = props[ SkillEnergyWeapons ] - 10;
        props[ SkillUnarmed ] = props[ SkillUnarmed ] - 10;
        props[ SkillMeleeWeapons ] = props[ SkillMeleeWeapons ] - 10;
        props[ SkillThrowing ] =  props[ SkillThrowing ] - 10;
    }

    props[ SkillSmallGuns ] = props[ SkillSmallGuns ] + ( 5 + 4 * props[ AgilityBase ] );
    props[ SkillBigGuns ] = props[ SkillBigGuns ] + ( 0 + 2 * props[ AgilityBase ] );
    props[ SkillEnergyWeapons ] = props[ SkillEnergyWeapons ] + ( 0 + 2 * props[ AgilityBase ] );
    props[ SkillUnarmed ] = props[ SkillUnarmed ] + ( 30 + 2 * ( props[ AgilityBase ] + props[ StrengthBase ] ) );
    props[ SkillMeleeWeapons ] = props[ SkillMeleeWeapons ] + ( 20 + 2 * ( props[ AgilityBase ] + props[ StrengthBase ] ) );
    props[ SkillThrowing ] = props[ SkillThrowing ] + ( 0 + 4 * props[ AgilityBase ] );
    props[ SkillFirstAid ] = props[ SkillFirstAid ] + ( 0 + 2 * ( props[ PerceptionBase ] + props[ IntellectBase ] ) );
    props[ SkillDoctor ] = props[ SkillDoctor ] + ( 5 + props[ PerceptionBase ] + props[ IntellectBase ] );
    props[ SkillSneak ] = props[ SkillSneak ] + ( 5 + 3 * props[ AgilityBase ] );
    props[ SkillLockpick ] = props[ SkillLockpick ] + ( 10 + props[ PerceptionBase ] + props[ AgilityBase ] );
    props[ SkillSteal ] = props[ SkillSteal ] + ( 0 + 3 * props[ AgilityBase ] );
    props[ SkillTraps ] = props[ SkillTraps ] + ( 10 + props[ PerceptionBase ] + props[ AgilityBase ] );
    props[ SkillScience ] = props[ SkillScience ] + ( 0 + 4 * props[ IntellectBase ] );
    props[ SkillRepair ] = props[ SkillRepair ] + ( 0 + 3 * props[ IntellectBase ] );
    props[ SkillSpeech ] = props[ SkillSpeech ] + ( 0 + 5 * props[ CharismaBase ] );
    props[ SkillBarter ] = props[ SkillBarter ] + ( 0 + 4 * props[ CharismaBase ] );
    props[ SkillGambling ] = props[ SkillGambling ] + ( 0 + 5 * props[ LuckBase ] );
    props[ SkillOutdoorsman ] = props[ SkillOutdoorsman ] + ( 0 + 2 * ( props[ EnduranceBase ] + props[ IntellectBase ] ) );

    if( props[ TagSkill1 ] != CritterProperty::Invalid )
        props[ CritterProperty( props[ TagSkill1 ] ) ] = props[ CritterProperty( props[ TagSkill1 ] ) ] + 20;
    if( props[ TagSkill2 ] != CritterProperty::Invalid )
        props[ CritterProperty( props[ TagSkill2 ] ) ] = props[ CritterProperty( props[ TagSkill2 ] ) ] + 20;
    if( props[ TagSkill3 ] != CritterProperty::Invalid )
        props[ CritterProperty( props[ TagSkill3 ] ) ] = props[ CritterProperty( props[ TagSkill3 ] ) ] + 20;

    if( props[ IsTraitFastMetabolism ] != 0 )
    {
        props[ RadiationResistanceBase ] = props[ RadiationResistanceBase ] - props[ EnduranceBase ] * 2;
        props[ PoisonResistanceBase ] = props[ PoisonResistanceBase ] - props[ EnduranceBase ] * 5;
        props[ HealingRateBase ] = props[ HealingRateBase ] + 2;
    }
    if( props[ IsTraitBruiser ] != 0 )
        props[ ActionPointsBase ] = props[ ActionPointsBase ] - 2;
    if( props[ IsTraitKamikaze ] != 0 )
    {
        props[ ArmorClassBase ] = props[ ArmorClassBase ] - props[ AgilityBase ];
        props[ SequenceBase ] = props[ SequenceBase ] + 5;
    }
    if( props[ IsTraitHeavyHanded ] != 0 )
        props[ MeleeDamageBase ] = props[ MeleeDamageBase ] + 4;
    if( props[ IsTraitFinesse ] != 0 )
        props[ CriticalChanceBase ] = props[ CriticalChanceBase ] + 10;
    if( props[ IsTraitHeavyHanded ] != 0 )
        props[ MaxCriticalBase ] = props[ MaxCriticalBase ] - 30;
    if( props[ IsTraitFastShot ] != 0 )
        props[ IsNoAim ] = 1;

    #ifdef __CLIENT
    // Runtime calculations, only for client registration
    props[ ArmorClassBase ] = props[ ArmorClassBase ] + ( props[ AgilityBase ] );
    props[ MaxLifeBase ] = props[ MaxLifeBase ] + ( props[ StrengthBase ] + props[ EnduranceBase ] * 2 );
    props[ ActionPointsBase ] = props[ ActionPointsBase ] + ( props[ AgilityBase ] / 2 );
    props[ CarryWeightBase ] = props[ CarryWeightBase ] + ( LBS_TO_GRAMM( 25 + props[ StrengthBase ] * ( 25 - props[ IsTraitSmallFrame ] * 10 ) ) );
    props[ MeleeDamageBase ] = props[ MeleeDamageBase ] + ( ( props[ StrengthBase ] > 6 ? props[ StrengthBase ] - 5 : 1 ) );
    props[ PoisonResistanceBase ] = props[ PoisonResistanceBase ] + ( props[ EnduranceBase ] * 5 );
    props[ RadiationResistanceBase ] = props[ RadiationResistanceBase ] + ( props[ EnduranceBase ] * 2 );
    props[ SequenceBase ] = props[ SequenceBase ] + ( props[ PerceptionBase ] * 2 );
    props[ HealingRateBase ] = props[ HealingRateBase ] + ( MAX( 1, props[ EnduranceBase ] / 3 ) );
    props[ CriticalChanceBase ] = props[ CriticalChanceBase ] + ( props[ LuckBase ] );
    #endif

    props[ MaxLifeBase ] = props[ MaxLifeBase ] + 15;
    props[ ActionPointsBase ] = props[ ActionPointsBase ] + 5;
    props[ CurrentHp ] = props[ MaxLifeBase ];
    props[ CurrentAp ] = props[ ActionPointsBase ] * 100;

    #ifdef PLAYERS_3D
    Fill3DRegistrationParameters( props );
    #endif
}

#ifdef __CLIENT
# ifdef PLAYERS_3D
import void Fill3DRegistrationParameters( int[]& params ) from "Client3dChaReg";
# endif

dict< CritterProperty, int > GenerateRegProps()
{
    dict< CritterProperty, int > regProps;
    regProps[ StrengthBase ] = 5;
    regProps[ PerceptionBase ] = 5;
    regProps[ EnduranceBase ] = 5;
    regProps[ CharismaBase ] = 5;
    regProps[ IntellectBase ] = 5;
    regProps[ AgilityBase ] = 5;
    regProps[ LuckBase ] = 5;
    regProps[ Age ] = Random( AGE_MIN, AGE_MAX );
    regProps[ Gender ] = GENDER_MALE;
    regProps[ TagSkill1 ] = CritterProperty::Invalid;
    regProps[ TagSkill2 ] = CritterProperty::Invalid;
    regProps[ TagSkill3 ] = CritterProperty::Invalid;
    for( uint i = 0; i < CritterPropertyTraits.length(); i++ )
        regProps.setIfNotExist( CritterPropertyTraits[ i ], 0 );
    return regProps;
}

// Check valid of input data
bool CritterGenerateCheck( dict< CritterProperty, int >& props )
{
    // Check name
    uint nameError = CheckPlayerName( __RegName );
    if( nameError != 0 )
    {
        Message( GetMsgStr( TEXTMSG_GAME, nameError ) );
        return false;
    }

    // Check special
    int special = 0;
    for( uint i = 0; i < CritterPropertySpecialBase.length(); i++ )
    {
        if( props[ CritterPropertySpecialBase[ i ] ] < 1 || props[ CritterPropertySpecialBase[ i ] ] > 10 )
        {
            Message( GetMsgStr( TEXTMSG_GAME, STR_NET_WRONG_SPECIAL ) );
            return false;
        }
        special += props[ CritterPropertySpecialBase[ i ] ];
    }
    if( special != __StartSpecialPoints )
    {
        Message( GetMsgStr( TEXTMSG_GAME, STR_NET_WRONG_SPECIAL ) );
        return false;
    }

    // Check choosed tag skills
    if( ( props[ TagSkill1 ] != CritterProperty::Invalid && CritterPropertySkills.find( CritterProperty( props[ TagSkill1 ] ) ) == -1 ) ||
        ( props[ TagSkill2 ] != CritterProperty::Invalid && CritterPropertySkills.find( CritterProperty( props[ TagSkill2 ] ) ) == -1 ) ||
        ( props[ TagSkill3 ] != CritterProperty::Invalid && CritterPropertySkills.find( CritterProperty( props[ TagSkill3 ] ) ) == -1 ) )
    {
        Message( GetMsgStr( TEXTMSG_GAME, STR_NET_WRONG_TAGSKILL ) );
        return false;
    }
    return true;
}
#endif

#ifndef __CLIENT
void NpcProcessLevel( Critter& npc ) // Export
{
    for( int i = 0, j = npc.Level; i < j; i++ )
    {
        // Todo: ...
        // npc.MaxLife += 10;
    }
}

int CritterGetSneakCoefficient( const Critter& cr )
{
    return cr.SkillSneak;
}

int CritterGetBarterCoefficient( const Critter& cr )
{
    return cr.SkillBarter;
}
#endif

uint CheckPlayerName( const string& name )
{
    // Length
    if( name.length() < __MinNameLength || name.length() > __MaxNameLength )
        return STR_NET_LOGINPASS_WRONG;

    // Valid letters
    string allLetters = __ValidNameLettersCommon + __ValidNameLettersCulture1 + __ValidNameLettersCulture2;
    for( uint i = 0, j = name.length(); i < j; i++ )
        if( findFirst( allLetters, name[ i ] ) == -1 )
            return STR_NET_PASS_WRONG_CHARS;

    // Spaces
    if( name[ 0 ] == " " || name[ -1 ] == " " )
        return STR_NET_BEGIN_END_SPACES;
    for( int i = 0, j = name.length() - 1; i < j; i++ )
        if( name[ i ] == " " && name[ i + 1 ] == " " )
            return STR_NET_TWO_SPACE;

    // Different cultures
    uint letters1 = 0;
    uint letters2 = 0;
    for( int i = 0, j = name.length() - 1; i < j; i++ )
    {
        if( findFirst( __ValidNameLettersCulture1, name[ i ] ) != -1 )
            letters1++;
        else if( findFirst( __ValidNameLettersCulture2, name[ i ] ) != -1 )
            letters2++;
    }
    if( letters1 > 0 && letters2 > 0 )
        return STR_NET_DIFFERENT_LANG;

    // Too many common symbols
    if( ( letters1 + letters2 ) * 100 / name.length() < 70 )
        return STR_NET_MANY_SYMBOLS;

    // All fine, return zero
    return 0;
}

// Unarmed item
#pragma content Item unarmed_strong_punch
#pragma content Item unarmed_hammer_punch
#pragma content Item unarmed_haymaker
#pragma content Item unarmed_jab
#pragma content Item unarmed_palm_strike
#pragma content Item unarmed_piercing_strike
#pragma content Item unarmed_kick
#pragma content Item unarmed_strong_kick
#pragma content Item unarmed_snap_kick
#pragma content Item unarmed_power_kick
#pragma content Item unarmed_hip_kick
#pragma content Item unarmed_hook_kick
#pragma content Item unarmed_piercing_kick

hash[] UnarmedWeapons =
{
    0,     // Is same as Content::Item::default_weapon
    Content::Item::unarmed_strong_punch,
    Content::Item::unarmed_hammer_punch,
    Content::Item::unarmed_haymaker,
    Content::Item::unarmed_jab,
    Content::Item::unarmed_palm_strike,
    Content::Item::unarmed_piercing_strike,
    Content::Item::unarmed_kick,
    Content::Item::unarmed_strong_kick,
    Content::Item::unarmed_snap_kick,
    Content::Item::unarmed_power_kick,
    Content::Item::unarmed_hip_kick,
    Content::Item::unarmed_hook_kick,
    Content::Item::unarmed_piercing_kick,
};

bool VerifyUnarmedItem( Critter& cr, hash pid )
{
    if( pid == 0 )
        return true;
    if( !UnarmedWeapons.exists( pid ) )
        return false;
    const Item@ proto = GetProtoItem( pid );
    if( cr.Strength < proto.Weapon_MinStrength || cr.Agility < proto.Weapon_UnarmedMinAgility )
        return false;
    if( cr.Level < proto.Weapon_UnarmedMinLevel || cr.SkillUnarmed < proto.Weapon_UnarmedMinUnarmed )
        return false;
    return true;
}

#ifdef __CLIENT
void SwitchUnarmedWeapon( Critter& cr, bool next )
{
    hash        curPid = cr.HandsItemProtoId;
    const Item@ proto = GetProtoItem( curPid != 0 ? curPid : Content::Item::default_weapon );
    uint8       mode = cr.HandsItemMode;
    uint8       use = mode & 0xF;
    uint8       aim = mode >> 4;
    if( next && aim == HIT_LOCATION_NONE && !cr.IsNoAim && _WeaponAim( proto, use ) )
    {
        aim = HIT_LOCATION_TORSO;
        cr.HandsItemMode = use | ( aim << 4 );
        return;
    }

    if( !next && aim != HIT_LOCATION_NONE )
    {
        aim = HIT_LOCATION_NONE;
        cr.HandsItemMode = use | ( aim << 4 );
        return;
    }

    int index = UnarmedWeapons.find( curPid );
    if( index != -1 )
    {
        int startIndex = index;
        while( true )
        {
            index += ( next ? 1 : -1 );
            if( index >= int( UnarmedWeapons.length() ) )
                index = 0;
            else if( index < 0 )
                index = UnarmedWeapons.length() - 1;

            if( index == startIndex )
                break;
            if( VerifyUnarmedItem( cr, UnarmedWeapons[ index ] ) )
                break;
        }
    }
    else
    {
        index = 0;
    }

    hash pid = UnarmedWeapons[ index ];
    if( pid != curPid  )
    {
        cr.HandsItemMode = 0;
        cr.HandsItemProtoId = pid;

        @proto = GetProtoItem( pid != 0 ? pid : Content::Item::default_weapon );
        if( !next && !cr.IsNoAim && _WeaponAim( proto, 0 ) )
        {
            aim = HIT_LOCATION_TORSO;
            cr.HandsItemMode = aim << 4;
        }
    }
}

void SwitchMainItemMode( bool next )
{
    Critter@ chosen = GetChosen();
    if( chosen is null )
        return;

    Item@ item = @chosen.GetItem( 0, SLOT_HAND1 );
    if( item is null )
    {
        SwitchUnarmedWeapon( chosen, next );
    }
    else
    {
        if( next )
            CustomCall( "NextItemMode" );
        else
            CustomCall( "NextItemMode Prev" );
    }
}
#endif

void CritterSetHandsItemProtoId( const Critter& cr, CritterProperty prop, uint& newValue )
{
    if( !VerifyUnarmedItem( cr, newValue ) )
        newValue = cr.HandsItemProtoId;
}

void CritterSetHandsItemMode( const Critter& cr, CritterProperty prop, uint8& newValue )
{
    // Check uses and aiming
}

import int GetDrugEffect( Critter& cr, CritterProperty prop ) from "Drugs";

#define CONVERT_GRAMM              # (x)               ( ( x ) * 453 )
#define TB_BATTLE_TIMEOUT_CHECK    # (to)    ( ( to ) > __FullSecond && ( to ) - __FullSecond > 10000000 )

int CritterGetStrength( const Critter& cr )
{
    // Base value
    int val = cr.StrengthBase;

    // Adrenaline rush perk
    if( cr.PerkAdrenalineRush != 0 && IS_TIMEOUT( cr.TimeoutBattle ) &&
        cr.CurrentHp <= ( cr.MaxLifeBase + cr.StrengthBase + cr.EnduranceBase * 2 ) / 2 )
        val += 1;

    // Armor perk
    int armorPerk = cr.CurrentArmorPerk;
    if( armorPerk == ARMOR_PERK_POWERED )
        val += 3;
    else if( armorPerk == ARMOR_PERK_ADVANCED_I || armorPerk == ARMOR_PERK_ADVANCED_II )
        val += 4;

    // Drug effect
    val += GetDrugEffect( cr, StrengthBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetPerception( const Critter& cr )
{
    // Base value
    int val = ( cr.IsDamagedEye ? 1 : cr.PerceptionBase );

    // Night person perk
    if( cr.IsTraitNightPerson )
        val += GetNightPersonBonus();

    // Drug effect
    val += GetDrugEffect( cr, PerceptionBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetEndurance( const Critter& cr )
{
    // Base value
    int val = cr.EnduranceBase;

    // Drug effect
    val += GetDrugEffect( cr, EnduranceBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetCharisma( const Critter& cr )
{
    // Base value
    int val = cr.CharismaBase;

    // Armor perk
    if( cr.CurrentArmorPerk == ARMOR_PERK_CHARISMA )
        val += 1;

    // Drug effect
    val += GetDrugEffect( cr, CharismaBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetIntellegence( const Critter& cr )
{
    // Base value
    int val = cr.IntellectBase;

    // Night person perk
    if( cr.IsTraitNightPerson )
        val += GetNightPersonBonus();

    // Drug effect
    val += GetDrugEffect( cr, IntellectBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetAgility( const Critter& cr )
{
    // Base value
    int val = cr.AgilityBase;

    // Drug effect
    val += GetDrugEffect( cr, AgilityBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetLuck( const Critter& cr )
{
    // Base value
    int val = cr.LuckBase;

    // Drug effect
    val += GetDrugEffect( cr, LuckBase );

    return CLAMP( val, 1, 10 );
}

int CritterGetMaxLife( const Critter& cr )
{
    int val = cr.MaxLifeBase + cr.StrengthBase + cr.EnduranceBase * 2;
    val += GetDrugEffect( cr, MaxLifeBase );
    return CLAMP( val, 1, 9999 );
}

int CritterGetActionPoints( const Critter& cr )
{
    int val = cr.ActionPointsBase + CritterGetAgility( cr ) / 2;
    val += GetDrugEffect( cr, ActionPointsBase );
    return CLAMP( val, 1, 9999 );
}

int CritterGetMaxMoveAp( const Critter& cr )
{
    int val = cr.MaxMoveApBase;
    val += GetDrugEffect( cr, MaxMoveApBase );
    return CLAMP( val, 0, 9999 );
}

bool CritterGetIsOverweight( const Critter& cr )
{
    return int( cr.ItemsWeight() ) > CritterGetCarryWeight( cr );
}

int CritterGetCarryWeight( const Critter& cr )
{
    int val = MAX( cr.CarryWeightBase, 0 );
    val += GetDrugEffect( cr, CarryWeightBase );
    val += CONVERT_GRAMM( 25 + CritterGetStrength( cr ) * ( 25 - ( cr.IsTraitSmallFrame ? 10 : 0 ) ) );
    return CLAMP( val, 0, 2000000000 );
}

int CritterGetSequence( const Critter& cr )
{
    int val = cr.SequenceBase + CritterGetPerception( cr ) * 2;
    val += GetDrugEffect( cr, SequenceBase );
    return CLAMP( val, 0, 9999 );
}

int CritterGetMeleeDamage( const Critter& cr )
{
    int strength = CritterGetStrength( cr );
    int val = cr.MeleeDamageBase + ( strength > 6 ? strength - 5 : 1 );
    val += GetDrugEffect( cr, MeleeDamageBase );
    return CLAMP( val, 1, 9999 );
}

int CritterGetHealingRate( const Critter& cr )
{
    int e = CritterGetEndurance( cr );
    int val = cr.HealingRateBase + MAX( 1, e / 3 );
    val += GetDrugEffect( cr, HealingRateBase );
    return CLAMP( val, 0, 9999 );
}

int CritterGetCriticalChance( const Critter& cr )
{
    int val = cr.CriticalChanceBase + CritterGetLuck( cr );
    val += GetDrugEffect( cr, CriticalChanceBase );
    return CLAMP( val, 0, 100 );
}

int CritterGetMaxCritical( const Critter& cr )
{
    int val = cr.MaxCriticalBase;
    val += GetDrugEffect( cr, MaxCriticalBase );
    return CLAMP( val, -100, 100 );
}

int CritterGetArmorClass( const Critter& cr )
{
    int         val = cr.ArmorClassBase + CritterGetAgility( cr ) + cr.TurnBasedAc;
    val += GetDrugEffect( cr, ArmorClassBase );
    const Item@ armor = cr.GetItem( 0, SLOT_ARMOR );
    if( valid( armor ) && armor.Type == Armor )
        val += armor.Armor_AC * ( 100 - GetDeteriorationProc( armor ) ) / 100;
    return CLAMP( val, 0, 90 );
}

int[] @ CritterGetDamageResistance( const Critter &cr )
{
    const Item@ armor = cr.GetSlotItem( SLOT_ARMOR );
    uint        dp = 0;
    if( armor.Id != 0 && armor.Type == Armor )
        dp = 100 - GetDeteriorationProc( armor );

    int[] result =
    {
        0,
        cr.NormalResistanceBase + armor.Armor_DRNormal * dp / 100,
        cr.LaserResistanceBase + armor.Armor_DRLaser * dp / 100,
        cr.FireResistanceBase + armor.Armor_DRFire * dp / 100,
        cr.PlasmaResistanceBase + armor.Armor_DRPlasma * dp / 100,
        cr.ElectricityResistanceBase + armor.Armor_DRElectr * dp / 100,
        cr.EmpResistanceBase + armor.Armor_DREmp * dp / 100,
        cr.ExplodeResistanceBase + armor.Armor_DRExplode * dp / 100,
        cr.PoisonResistanceBase  + CritterGetEndurance( cr ) * 5,
        cr.RadiationResistanceBase + CritterGetEndurance( cr ) * 2,
    };

    // Armor perk
    int armorPerk = cr.CurrentArmorPerk;
    if( armorPerk == ARMOR_PERK_POWERED )
        result[ DAMAGE_RADIATION ] += 30;
    else if( armorPerk == ARMOR_PERK_COMBAT )
        result[ DAMAGE_RADIATION ] += 20;
    else if( armorPerk == ARMOR_PERK_ADVANCED_I )
        result[ DAMAGE_RADIATION ] += 60;
    else if( armorPerk == ARMOR_PERK_ADVANCED_II )
        result[ DAMAGE_RADIATION ] += 75;

    // Drug effects
    for( uint i = 0; i < CritterPropertyResistsBase.length(); i++ )
        result[ i ] += GetDrugEffect( cr, CritterPropertyResistsBase[ i ] );

    // Clamp
    for( uint i = 0; i < result.length(); i++ )
        result[ i ] = CLAMP( result[ i ], 0, i != DAMAGE_EMP ? 90 : 999 );
    return result;
}

int CritterGetNormalResistance( const Critter& cr )
{
    return CritterGetDamageResistance( cr )[ DAMAGE_NORMAL ];
}

int CritterGetPoisonResistance( const Critter& cr )
{
    return CritterGetDamageResistance( cr )[ DAMAGE_POISON ];
}

int CritterGetRadiationResistance( const Critter& cr )
{
    return CritterGetDamageResistance( cr )[ DAMAGE_RADIATION ];
}

int[] @ CritterGetDamageThreshold( const Critter &cr )
{
    const Item@ armor = cr.GetSlotItem( SLOT_ARMOR );
    uint        dp = 0;
    if( armor.Id != 0 && armor.Type == Armor )
        dp = 100 - GetDeteriorationProc( armor );

    int[] result =
    {
        0,
        cr.NormalThresholdBase + armor.Armor_DTNormal * dp / 100,
        cr.LaserThresholdBase + armor.Armor_DTLaser * dp / 100,
        cr.FireThresholdBase + armor.Armor_DTFire * dp / 100,
        cr.PlasmaThresholdBase + armor.Armor_DTPlasma * dp / 100,
        cr.ElectricityThresholdBase + armor.Armor_DTElectr * dp / 100,
        cr.EmpThresholdBase + armor.Armor_DTEmp * dp / 100,
        cr.ExplodeThresholdBase + armor.Armor_DTExplode * dp / 100,
        0,
        0,
    };

    // Drug effects
    for( uint i = 0; i < CritterPropertyThresholdsBase.length(); i++ )
        result[ i ] += GetDrugEffect( cr, CritterPropertyThresholdsBase[ i ] );

    // Clamp
    for( uint i = 0; i < result.length(); i++ )
        result[ DAMAGE_EMP ] = CLAMP( result[ DAMAGE_EMP ], 0, 999 );
    return result;
}

bool CritterGetIsInjured( const Critter& cr )
{
    return cr.IsDamagedEye || cr.IsDamagedRightLeg || cr.IsDamagedLeftLeg || cr.IsDamagedRightArm || cr.IsDamagedLeftArm;
}

bool CritterGetIsAddicted( const Critter& cr )
{
    bool[] addictions = cr.Addictions;
    for( uint i = 0; i < addictions.length(); i++ )
        if( addictions[ i ] )
            return true;
    return false;
}

CritterProperty[] @ CritterGetTagSkills( const Critter &cr )
{
    CritterProperty[] result;
    if( cr.TagSkill1 != Invalid )
        result.insertLast( cr.TagSkill1 );
    if( cr.TagSkill2 != Invalid )
        result.insertLast( cr.TagSkill2 );
    if( cr.TagSkill3 != Invalid )
        result.insertLast( cr.TagSkill3 );
    return result;
}

uint CritterGetLookDistance( const Critter& cr )
{
    int look = __LookNormal + cr.Perception * 3 + cr.BonusLook + cr.GetMultihex();
    if( look < int(__LookMinimum) )
        look = __LookMinimum;
    return look;
}

bool Item_Weapon_IsHtHAttack( const Item& item, uint8 mode )
{
    uint8 use = mode & 0xF;
    if( item.Type != Weapon || ( ( item.Weapon_ActiveUses >> use ) & 1 ) == 0 )
        return false;
    CritterProperty skill = _WeaponSkill( item, use );
    return skill == SkillUnarmed || skill == SkillMeleeWeapons;
}

bool Item_Weapon_IsGunAttack( const Item& item, uint8 mode )
{
    uint8 use = mode & 0xF;
    if( item.Type != Weapon || ( ( item.Weapon_ActiveUses >> use ) & 1 ) == 0 )
        return false;
    CritterProperty skill = _WeaponSkill( item, use );
    return skill == SkillSmallGuns || skill == SkillBigGuns || skill == SkillEnergyWeapons;
}

bool Item_Weapon_IsRangedAttack( const Item& item, uint8 mode )
{
    uint8 use = mode & 0xF;
    if( item.Type != Weapon || ( ( item.Weapon_ActiveUses >> use ) & 1 ) == 0 )
        return false;
    CritterProperty skill = _WeaponSkill( item, use );
    return skill == SkillSmallGuns || skill == SkillBigGuns || skill == SkillEnergyWeapons || skill == SkillThrowing;
}

// Engine callbacks

uint GetItemUseApCost( const Critter& cr, const Item& item, uint8 mode )
{
    uint8 use = mode & 0xF;
    uint8 aim = mode >> 4;
    int   apCost = 1;

    if( use == USE_USE )
    {
        if( TB_BATTLE_TIMEOUT_CHECK( cr.TimeoutBattle ) )
            apCost = __TbApCostUseItem;
        else
            apCost = __RtApCostUseItem;
    }
    else if( use == USE_RELOAD )
    {
        if( TB_BATTLE_TIMEOUT_CHECK( cr.TimeoutBattle ) )
            apCost = __TbApCostReloadWeapon;
        else
            apCost = __RtApCostReloadWeapon;

        if( item.Type == Weapon && item.Weapon_Perk == WEAPON_PERK_FAST_RELOAD )
            apCost--;
    }
    else if( use >= USE_PRIMARY && use <= USE_THIRD && item.Type == Weapon )
    {
        bool hthAttack = Item_Weapon_IsHtHAttack( item, use );
        bool rangedAttack = Item_Weapon_IsRangedAttack( item, use );

        apCost = _WeaponApCost( item, use );
        if( aim != 0 )
            apCost += GetAimApCost( aim );
        if( hthAttack && cr.PerkBonusHthAttacks != 0 )
            apCost--;
        if( rangedAttack && cr.PerkBonusRateOfFire != 0 )
            apCost--;
        if( cr.IsTraitFastShot && !hthAttack )
            apCost--;
    }

    if( apCost < 1 )
        apCost = 1;
    return apCost;
}

uint get_use_ap_cost( const Critter& cr, const Item& item, uint8 mode )
{
    return GetItemUseApCost( cr, item, mode );
}

uint GetItemAttackDistantion( const Critter& cr, const Item& proto, uint8 mode )
{
    if( proto.Type != Weapon )
        return 0;

    uint8           use = mode & 0xF;
    CritterProperty skill = _WeaponSkill( proto, use );
    int             dist = _WeaponMaxDist( proto, use );
    int             strength = CritterGetStrength( cr );
    int             heaveHo = cr.PerkHeaveHo;
    if( skill == SkillThrowing )
        dist = MIN( dist, int(3) * MIN( int(10), strength + 2 * heaveHo ) );
    if( Item_Weapon_IsHtHAttack( proto, mode ) && cr.IsRangeHth )
        dist++;
    dist += cr.GetMultihex();
    if( dist < 0 )
        dist = 0;
    return dist;
}

uint GetActiveItemAttackDistantion( Critter& cr )
{
    const Item@ item = cr.GetSlotItem( SLOT_HAND1 );
    return GetItemAttackDistantion( cr, item, item.Mode );
}

uint get_attack_distantion( Critter& cr, Item& item, uint8 mode )
{
    return GetItemAttackDistantion( cr, item, mode );
}

#ifdef PLAYERS_3D
int[] @ CritterGetCustomAnim3dLayer( Critter & cr )
{
    int[] result( ANIM3D_LAYERS_COUNT );
    result[ ANIM3D_LAYER_SKIN ] = cr.LayerSkin;
    result[ ANIM3D_LAYER_RHANDLE ] = cr.LayerRHandle;
    result[ ANIM3D_LAYER_LHANDLE ] = cr.LayerLHandle;
    result[ ANIM3D_LAYER_BODY ] = cr.LayerBody;
    result[ ANIM3D_LAYER_FEET ] = cr.LayerFeet;
    result[ ANIM3D_LAYER_HANDS ] = cr.LayerHands;
    result[ ANIM3D_LAYER_HEAD ] = cr.LayerHead;
    result[ ANIM3D_LAYER_HAIR ] = cr.LayerHair;
    result[ ANIM3D_LAYER_EYE ] = cr.LayerEye;
    result[ ANIM3D_LAYER_MUSTACHE ] = cr.LayerMustache;
    result[ ANIM3D_LAYER_PONYTAIL ] = cr.LayerPonytail;
    result[ ANIM3D_LAYER_BEARD ] = cr.LayerBeard;
    result[ ANIM3D_LAYER_SHOULDER ] = cr.LayerShoulder;
    result[ ANIM3D_LAYER_ARMLET ] = cr.LayerArmlet;
    result[ ANIM3D_LAYER_BACK ] = cr.LayerBack;
    result[ ANIM3D_LAYER_BACKPACK ] = cr.LayerBackpack;
    return result;
}
#endif

// Generic stuff

int GetNightPersonBonus()
{
    if( __Hour < 6 || __Hour > 18 )
        return 1;
    if( __Hour == 6 && __Minute == 0 )
        return 1;
    if( __Hour == 18 && __Minute > 0 )
        return 1;
    return -1;
}

uint GetAimApCost( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_TORSO:
        return __ApCostAimTorso;
    case HIT_LOCATION_EYES:
        return __ApCostAimEyes;
    case HIT_LOCATION_HEAD:
        return __ApCostAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __ApCostAimArms;
    case HIT_LOCATION_GROIN:
        return __ApCostAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __ApCostAimLegs;
    case HIT_LOCATION_NONE:
    case HIT_LOCATION_UNCALLED:
    default:
        break;
    }
    return 0;
}

int GetDeteriorationProc( Item& item )
{
    int val = item.Deterioration * 100 / MAX_DETERIORATION;
    return CLAMP( val, 0, 100 );
}
